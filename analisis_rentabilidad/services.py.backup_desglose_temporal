# -*- coding: utf-8 -*-
"""
Servicios del mÃ³dulo de AnÃ¡lisis de Rentabilidad
LÃ³gica de negocio para el anÃ¡lisis de rentabilidad (Control de Ingreso Real)
"""

import pandas as pd
import sys
import pytz
from datetime import datetime, timedelta, date
import calendar
from dateutil.relativedelta import relativedelta

from config import CANALES_CLASIFICACION, MAZATLAN_TZ
from database import load_data_improved, get_db_connection
from clasificacion.services import (
    obtener_skus_por_clasificacion_clickhouse,
    clasificar_sku_por_ventas
)
from utils import clean_data_for_json


def get_default_resumen_general():
    """Retorna un diccionario con valores por defecto para resumen_general"""
    return {
        'ventas_totales': 0,
        'costo_venta': 0,  # Campo faltante
        'costo_venta_porcentaje': 0,
        'evolucion_costo': [],
        'evolucion_ventas': [],
        'evolucion_ingreso': [],
        'evolucion_ingreso_nominal': [],  # Campo faltante
        'evolucion_roi': [],
        'gastos_directos': 0,
        'gastos_directos_porcentaje': 0,
        # DESGLOSE INDIVIDUAL DE GASTOS DIRECTOS
        'comision_periodo': 0,
        'destino_periodo': 0,
        'milla_periodo': 0,
        # PORCENTAJES INDIVIDUALES DE CADA COMPONENTE
        'comision_porcentaje': 0,
        'destino_porcentaje': 0,
        'milla_porcentaje': 0,
        'ingreso_real': 0,
        # NUEVOS CAMPOS PARA TARJETAS DINÃMICAS
        'ventas_periodo_total': 0,
        'ingreso_real_periodo_total': 0,
        'num_transacciones': 0,
        'precio_promedio_ventas': 0,
        'precio_promedio_costo': 0,
        'precio_promedio_gastos': 0,
        'precio_promedio_ingreso': 0,
        'cantidad_total_unidades': 0,
        'meta_total': 0,
        'meta_total_mes': 0,
        'cumplimiento_vs_meta_mes': 0,
        'cumplimiento_global': 0,
        # NUEVOS CAMPOS DE COMPARACIÃ“N CON PERÃODO ANTERIOR
        'ingreso_real_porcentaje': 0,
        'ingreso_real_porcentaje_anterior': 0,
        'variacion_ingreso_pct': 0,
        'periodo_comparacion': 'ComparaciÃ³n con perÃ­odo anterior',
        'dias_comparados': 0,
        # Campo ROI
        'roi_promedio': 0.0,
        'roi_promedio_anterior': 0.0,
        'variacion_roi_pct': 0.0
    }


def generar_todos_los_skus_optimizado(df_mes_actual, df_completo, fecha_inicio, fecha_fin, aÃ±o, mes):
    """
    FUNCIÃ“N SÃšPER OPTIMIZADA: Genera datos de TODOS los SKUs prioritarios en UNA SOLA operaciÃ³n

    Args:
        df_mes_actual: DataFrame del mes actual
        df_completo: DataFrame completo (3 meses)
        fecha_inicio: Fecha inicio del perÃ­odo
        fecha_fin: Fecha fin del perÃ­odo
        aÃ±o: AÃ±o para filtrar clasificaciones
        mes: Mes para filtrar clasificaciones

    Returns:
        Diccionario con datos de todos los tipos de SKUs:
        {
            'skus_estrella': [...],
            'skus_prometedores': [...],
            'skus_potenciales': [...]
        }
    """
    from datetime import datetime
    import time

    tiempo_inicio = time.time()
    print(f"ðŸš€ SUPER OPTIMIZADO: Generando TODOS los SKUs en una sola operaciÃ³n")

    # 1. Obtener TODAS las clasificaciones en UNA SOLA consulta
    clasificaciones_agrupadas = obtener_todas_clasificaciones_optimizado(aÃ±o, mes)

    # 2. âœ… NUEVO: Obtener datos de Ingreso Ideal (Silver.categorizacion_ingreso)
    tiempo_ingreso_ideal_inicio = time.time()
    datos_ingreso_ideal = obtener_ingreso_ideal_sku_canal()
    tiempo_ingreso_ideal_fin = time.time()
    print(f"â±ï¸  Carga Ingreso Ideal: {tiempo_ingreso_ideal_fin - tiempo_ingreso_ideal_inicio:.3f} segundos")

    # 2.5. âœ… OPTIMIZACIÃ“N CRÃTICA: Calcular variaciones UNA SOLA VEZ para TODOS los SKUs
    tiempo_variaciones_inicio = time.time()
    print(f"ðŸ”„ OPTIMIZACIÃ“N: Calculando variaciones para TODOS los SKUs en una sola operaciÃ³n...")

    # Obtener TODOS los SKUs de todas las clasificaciones
    todos_los_skus = []
    for clasificacion, skus_clasificacion in clasificaciones_agrupadas.items():
        if skus_clasificacion:
            skus_list = [sku_data['sku'] for sku_data in skus_clasificacion]
            todos_los_skus.extend(skus_list)

    # Expandir con gemelos para bÃºsqueda histÃ³rica
    todos_los_skus_con_gemelos = todos_los_skus.copy()
    for sku in todos_los_skus:
        if sku in PRODUCTOS_UNIFICADOS:
            gemelos = PRODUCTOS_UNIFICADOS[sku]
            todos_los_skus_con_gemelos.extend(gemelos)

    todos_los_skus_con_gemelos = list(set(todos_los_skus_con_gemelos))

    # Calcular variaciones UNA SOLA VEZ
    skus_anteriores_global = calcular_variaciones_temporales_skus(df_completo, todos_los_skus_con_gemelos)
    tiempo_variaciones_fin = time.time()
    print(f"âœ… OPTIMIZACIÃ“N: Variaciones calculadas en {tiempo_variaciones_fin - tiempo_variaciones_inicio:.3f} segundos")
    print(f"   ðŸ“Š {len(todos_los_skus)} SKUs principales + {len(todos_los_skus_con_gemelos) - len(todos_los_skus)} gemelos")

    # 3. Procesar cada tipo de SKU usando los datos obtenidos
    resultado = {
        'skus_estrella': [],
        'skus_prometedores': [],
        'skus_potenciales': [],
        'skus_revision': [],
        'skus_remover': []
    }

    # Mapeo de clasificaciones a keys del resultado
    mapeo_resultado = {
        'Estrella': 'skus_estrella',         # Revertido: mantener funcionamiento original
        'Prometedores': 'skus_prometedores',
        'Potenciales': 'skus_potenciales',
        'Revision': 'skus_revision',         # DB usa 'Revision' sin acento
        'Remover': 'skus_remover'
    }

    # Procesar cada clasificaciÃ³n
    print(f"ðŸ” DEBUG: Clasificaciones recibidas de DB: {list(clasificaciones_agrupadas.keys())}")
    print(f"ðŸ” DEBUG: Mapeo disponible: {list(mapeo_resultado.keys())}")

    for clasificacion, skus_clasificacion in clasificaciones_agrupadas.items():
        print(f"ðŸ” DEBUG: Procesando clasificaciÃ³n: '{clasificacion}' con {len(skus_clasificacion) if skus_clasificacion else 0} SKUs")

        if not skus_clasificacion:
            print(f"âš ï¸  No hay SKUs {clasificacion}")
            continue

        resultado_key = mapeo_resultado.get(clasificacion)
        if not resultado_key:
            print(f"âŒ DEBUG: No se encontrÃ³ mapeo para '{clasificacion}'. Mapeo disponible: {list(mapeo_resultado.keys())}")
            continue

        print(f"ðŸ“Š Procesando {len(skus_clasificacion)} SKUs {clasificacion}")

        # Extraer solo los SKUs para filtrar el DataFrame
        skus_list = [sku_data['sku'] for sku_data in skus_clasificacion]

        # âœ… MODIFICADO: Pasar datos de Ingreso Ideal Y variaciones pre-calculadas
        datos_skus = generar_datos_skus_genericos_optimizado(
            df_mes_actual, df_completo, fecha_inicio, fecha_fin, skus_list, clasificacion, datos_ingreso_ideal, skus_anteriores_global
        )

        resultado[resultado_key] = datos_skus

    tiempo_total = time.time() - tiempo_inicio
    print(f"ðŸŽ¯ SUPER OPTIMIZADO COMPLETADO: {tiempo_total:.3f} segundos")
    print(f"ðŸ“Š Resultados: Estrella({len(resultado['skus_estrella'])}), Prometedores({len(resultado['skus_prometedores'])}), Potenciales({len(resultado['skus_potenciales'])}), RevisiÃ³n({len(resultado['skus_revision'])}), Remover({len(resultado['skus_remover'])})")

    return resultado

def calcular_resumen_rentabilidad(df_ventas, f1, f2, df_completo=None, mes_seleccionado=None):
    """
    âœ… OPTIMIZADO: FunciÃ³n especÃ­fica para Control de Ingreso Real
    Calcula solo mÃ©tricas de rentabilidad sin lÃ³gica de metas ni cumplimiento.

    Elimina operaciones innecesarias de calcular_cumplimiento_metas():
    - CÃ¡lculos de cumplimiento vs metas
    - Comparaciones con metas inexistentes
    - ConstrucciÃ³n de cumplimiento_list que se descarta

    Args:
        df_ventas: DataFrame con datos de ventas del perÃ­odo
        f1, f2: Fechas de inicio y fin del perÃ­odo
        df_completo: DataFrame completo para comparaciones temporales (opcional)
        mes_seleccionado: Mes seleccionado para calcular evoluciÃ³n (opcional, por defecto mes actual)

    Returns:
        dict: resumen_general con mÃ©tricas de rentabilidad
    """
    import sys

    if df_ventas.empty:
        print("DEBUG: DataFrame de ventas vacÃ­o")
        return {}

    print(f"âœ… OPTIMIZADO: Calculando resumen de rentabilidad (sin metas)")
    print(f"PerÃ­odo: {f1} a {f2}")

    # Normalizar fechas para comparaciÃ³n
    df_ventas_naive = df_ventas.copy()
    df_ventas_naive["Fecha"] = df_ventas_naive["Fecha"].dt.tz_localize(None)

    # Filtrar solo datos vÃ¡lidos (excluir cancelados)
    ventas_periodo = df_ventas_naive[
        df_ventas_naive["estado"] != "Cancelado"
    ].copy()

    if ventas_periodo.empty:
        print("WARNING: No hay ventas vÃ¡lidas en el perÃ­odo")
        return {}

    print(f"âœ… Ventas vÃ¡lidas en perÃ­odo: {len(ventas_periodo)} transacciones")

    # âœ… CÃLCULOS OPTIMIZADOS: Solo mÃ©tricas necesarias usando campos pre-calculados
    ventas_totales_periodo = float(ventas_periodo["Total"].sum())
    costo_venta_periodo = float(ventas_periodo["Costo de venta"].sum())  # Ya incluye IVA
    gastos_directos_periodo = float(ventas_periodo["Gastos_directos"].sum())  # Pre-calculado
    ingreso_real_periodo = float(ventas_periodo["Ingreso real"].sum())  # Pre-calculado
    num_transacciones = len(ventas_periodo)
    cantidad_total_unidades = float(ventas_periodo["cantidad"].sum())

    # âœ… CÃLCULO INDIVIDUAL DE COMPONENTES DE GASTOS DIRECTOS
    comision_total_periodo = float(ventas_periodo['Comision por venta'].fillna(0).sum())
    destino_total_periodo = float(ventas_periodo['gastos_destino'].fillna(0).sum())
    milla_total_periodo = float(ventas_periodo['Ultima_milla'].fillna(0).sum())

    # CÃ¡lculos de porcentajes
    costo_venta_porcentaje = (costo_venta_periodo / ventas_totales_periodo * 100) if ventas_totales_periodo > 0 else 0
    gastos_directos_porcentaje = (gastos_directos_periodo / ventas_totales_periodo * 100) if ventas_totales_periodo > 0 else 0
    ingreso_real_porcentaje = (ingreso_real_periodo / ventas_totales_periodo * 100) if ventas_totales_periodo > 0 else 0

    # Calcular porcentajes individuales de componentes de gastos directos
    comision_porcentaje = (comision_total_periodo / ventas_totales_periodo * 100) if ventas_totales_periodo > 0 else 0
    destino_porcentaje = (destino_total_periodo / ventas_totales_periodo * 100) if ventas_totales_periodo > 0 else 0
    milla_porcentaje = (milla_total_periodo / ventas_totales_periodo * 100) if ventas_totales_periodo > 0 else 0

    # âœ… NUEVO: Calcular ROI usando la misma fÃ³rmula que la tabla para consistencia
    roi_promedio = (ingreso_real_periodo / costo_venta_periodo * 100) if costo_venta_periodo > 0 else 0.0

    print(f"âœ… ROI promedio calculado: {roi_promedio:.2f}% (usando fÃ³rmula: Ingreso_Real / Costo_Venta * 100)")

    # CÃ¡lculos de promedios por transacciÃ³n
    precio_promedio_ventas = ventas_totales_periodo / num_transacciones if num_transacciones > 0 else 0
    precio_promedio_costo = costo_venta_periodo / num_transacciones if num_transacciones > 0 else 0
    precio_promedio_gastos = gastos_directos_periodo / num_transacciones if num_transacciones > 0 else 0
    precio_promedio_ingreso = ingreso_real_periodo / num_transacciones if num_transacciones > 0 else 0

    # âœ… COMPARACIÃ“N TEMPORAL OPTIMIZADA (si estÃ¡ disponible)
    ingreso_real_porcentaje_anterior = 0.0
    variacion_ingreso_pct = 0.0
    ventas_totales_anterior = 0.0
    variacion_ventas_pct = 0.0
    periodo_comparacion = 'Sin comparaciÃ³n'
    dias_comparados = 0

    if df_completo is not None and not df_completo.empty:
        try:
            # LÃ³gica de comparaciÃ³n temporal simplificada
            from datetime import datetime, timedelta
            import calendar

            # Calcular mes anterior
            fecha_actual = datetime.now()
            mes_actual = fecha_actual.month
            aÃ±o_actual = fecha_actual.year

            mes_anterior = mes_actual - 1 if mes_actual > 1 else 12
            aÃ±o_anterior = aÃ±o_actual if mes_actual > 1 else aÃ±o_actual - 1

            # Filtrar datos del mes anterior
            df_completo_naive = df_completo.copy()
            df_completo_naive["Fecha"] = df_completo_naive["Fecha"].dt.tz_localize(None)

            primer_dia_anterior = datetime(aÃ±o_anterior, mes_anterior, 1)
            ultimo_dia_anterior = datetime(aÃ±o_anterior, mes_anterior, calendar.monthrange(aÃ±o_anterior, mes_anterior)[1])

            ventas_mes_anterior = df_completo_naive[
                (df_completo_naive["Fecha"] >= primer_dia_anterior) &
                (df_completo_naive["Fecha"] <= ultimo_dia_anterior) &
                (df_completo_naive["estado"] != "Cancelado")
            ]

            if not ventas_mes_anterior.empty:
                ventas_anterior_total = float(ventas_mes_anterior["Total"].sum())
                ingreso_anterior_total = float(ventas_mes_anterior["Ingreso real"].sum())
                ingreso_real_porcentaje_anterior = (ingreso_anterior_total / ventas_anterior_total * 100) if ventas_anterior_total > 0 else 0

                # Calcular variaciones
                variacion_ingreso_pct = ingreso_real_porcentaje - ingreso_real_porcentaje_anterior
                if ventas_anterior_total > 0:
                    variacion_ventas_pct = ((ventas_totales_periodo - ventas_anterior_total) / ventas_anterior_total * 100)

                ventas_totales_anterior = ventas_anterior_total
                periodo_comparacion = f"vs {calendar.month_name[mes_anterior]} {aÃ±o_anterior}"
                dias_comparados = (ultimo_dia_anterior - primer_dia_anterior).days + 1

                print(f"âœ… ComparaciÃ³n temporal: {periodo_comparacion}")
                print(f"âœ… VariaciÃ³n ingreso: {variacion_ingreso_pct:+.1f}pp")

        except Exception as e:
            print(f"WARNING: Error en comparaciÃ³n temporal: {e}")
            # Continuar con valores por defecto

    # âœ… RESULTADO OPTIMIZADO: Solo campos necesarios
    resumen_general = {
        # Campos principales usados en Control de Ingreso Real
        'ventas_totales': ventas_totales_periodo,
        'costo_venta': costo_venta_periodo,
        'costo_venta_porcentaje': costo_venta_porcentaje,
        'gastos_directos': gastos_directos_periodo,
        'gastos_directos_porcentaje': gastos_directos_porcentaje,
        'ingreso_real': ingreso_real_periodo,
        'ingreso_real_porcentaje': ingreso_real_porcentaje,
        'num_transacciones': num_transacciones,
        'precio_promedio_ventas': precio_promedio_ventas,
        'precio_promedio_costo': precio_promedio_costo,
        'precio_promedio_gastos': precio_promedio_gastos,
        'precio_promedio_ingreso': precio_promedio_ingreso,
        'cantidad_total_unidades': cantidad_total_unidades,

        # Campos de comparaciÃ³n temporal
        'ingreso_real_porcentaje_anterior': float(ingreso_real_porcentaje_anterior),
        'variacion_ingreso_pct': float(variacion_ingreso_pct),
        'ventas_totales_anterior': float(ventas_totales_anterior),
        'variacion_ventas_pct': float(variacion_ventas_pct),
        'periodo_comparacion': periodo_comparacion,
        'dias_comparados': dias_comparados,

        # Campos requeridos por template (valores fijos para compatibilidad)
        'tipo_meta': 'ventas',

        # Campos necesarios para template (valores reales)
        'comision_periodo': float(comision_total_periodo),
        'destino_periodo': float(destino_total_periodo),
        'milla_periodo': float(milla_total_periodo),
        'comision_porcentaje': float(comision_porcentaje),
        'destino_porcentaje': float(destino_porcentaje),
        'milla_porcentaje': float(milla_porcentaje),

        # âœ… NUEVO: Campo ROI
        'roi_promedio': float(roi_promedio),

        # âŒ ELIMINADOS: Campos innecesarios de metas
        # 'meta_total': 0.0,
        # 'cumplimiento_global': 0.0,
        # 'cumplimiento_vs_meta_mes': 0.0,
    }

    # ===== CALCULAR EVOLUCIÃ“N DE 3 MESES PARA GRÃFICOS =====
    evolucion_costo = []
    evolucion_ventas = []
    evolucion_ingreso = []
    evolucion_ingreso_nominal = []
    evolucion_roi = []

    try:
        import calendar

        # ðŸŽ¯ DETERMINAR FECHA DE REFERENCIA SEGÃšN MES SELECCIONADO
        hoy_sistema = datetime.now()
        mes_actual_sistema = hoy_sistema.month
        aÃ±o_actual_sistema = hoy_sistema.year
        dia_actual_sistema = hoy_sistema.day

        # Si no se especificÃ³ mes, usar el mes actual del sistema
        if mes_seleccionado is None:
            mes_seleccionado = mes_actual_sistema

        print(f"ðŸ“… Calculando evoluciÃ³n para mes seleccionado: {mes_seleccionado}")
        print(f"ðŸ“… Mes actual del sistema: {mes_actual_sistema}")

        # Determinar fecha de referencia y aÃ±o
        # Si el mes seleccionado es mayor al actual, asumimos que es del aÃ±o pasado
        if mes_seleccionado > mes_actual_sistema:
            aÃ±o_referencia = aÃ±o_actual_sistema - 1
        else:
            aÃ±o_referencia = aÃ±o_actual_sistema

        # Crear fecha de referencia del mes seleccionado
        fecha_referencia = pd.Timestamp(aÃ±o_referencia, mes_seleccionado, 1)

        print(f"ðŸ“… Fecha de referencia: {fecha_referencia.strftime('%Y-%m')}")

        # Calcular para los Ãºltimos 3 meses desde el mes seleccionado
        for i in range(3):
            fecha_mes = fecha_referencia.replace(day=1) - pd.DateOffset(months=i)
            aÃ±o_mes = fecha_mes.year
            mes_numero = fecha_mes.month
            mes_nombre = fecha_mes.strftime('%b')

            # ðŸŽ¯ DETERMINAR HASTA QUÃ‰ DÃA COMPARAR
            # SIEMPRE usar el mismo dÃ­a para todos los meses (comparaciÃ³n justa)
            # Ajustar si el mes tiene menos dÃ­as que el dÃ­a actual
            ultimo_dia_del_mes = calendar.monthrange(aÃ±o_mes, mes_numero)[1]
            dia_limite = min(dia_actual_sistema, ultimo_dia_del_mes)

            # Logging para debugging
            if mes_numero == mes_actual_sistema and aÃ±o_mes == aÃ±o_actual_sistema:
                print(f"  â†’ Mes actual del sistema ({mes_nombre}): usando dÃ­a {dia_limite} (de {dia_actual_sistema})")
            else:
                print(f"  â†’ Mes pasado ({mes_nombre}): usando dÃ­a {dia_limite} (mismo perÃ­odo que mes actual, mÃ¡x: {ultimo_dia_del_mes})")

            # Filtrar ventas del mes especÃ­fico hasta el dÃ­a lÃ­mite
            # IMPORTANTE: Incluir TODO el dÃ­a hasta las 23:59:59
            inicio_mes = pd.Timestamp(aÃ±o_mes, mes_numero, 1)
            fin_rango = pd.Timestamp(aÃ±o_mes, mes_numero, dia_limite, 23, 59, 59)

            # Usar df_completo si estÃ¡ disponible (para evoluciÃ³n 3 meses), sino cargar individual
            if df_completo is not None and not df_completo.empty:
                # Usar datos completos ya disponibles
                datos_fuente_naive = df_completo.copy()
                if 'Fecha' in datos_fuente_naive.columns:
                    datos_fuente_naive["Fecha"] = pd.to_datetime(datos_fuente_naive["Fecha"]).dt.tz_localize(None)

                ventas_mes = datos_fuente_naive[
                    (datos_fuente_naive["Fecha"] >= inicio_mes) &
                    (datos_fuente_naive["Fecha"] <= fin_rango) &
                    (datos_fuente_naive["estado"] != "Cancelado") &
                    (datos_fuente_naive['Channel'].isin(CANALES_CLASIFICACION))
                ].copy()
            else:
                # Fallback: cargar datos especÃ­ficos del mes (solo si no es el mes actual)
                if i == 0:  # Mes actual - usar datos ya cargados
                    ventas_mes = df_ventas_periodo_naive[
                        (df_ventas_periodo_naive["Fecha"] >= inicio_mes) &
                        (df_ventas_periodo_naive["Fecha"] <= fin_rango) &
                        (df_ventas_periodo_naive["estado"] != "Cancelado") &
                        (df_ventas_periodo_naive['Channel'].isin(CANALES_CLASIFICACION))
                    ].copy()
                else:  # Meses anteriores - sin datos disponibles
                    print(f"âš ï¸ Sin datos de {mes_nombre} - df_completo no disponible")
                    ventas_mes = pd.DataFrame()

            if not ventas_mes.empty:
                total_ventas_mes = ventas_mes['Total'].sum()
                total_costo_mes = ventas_mes['Costo de venta'].sum()

                # Usar campos pre-calculados si estÃ¡n disponibles, sino calcular
                if 'Gastos_directos' in ventas_mes.columns:
                    total_gastos_mes = ventas_mes['Gastos_directos'].sum()
                    ingreso_real_mes = ventas_mes['Ingreso real'].sum() if 'Ingreso real' in ventas_mes.columns else (total_ventas_mes - total_costo_mes - total_gastos_mes)
                else:
                    total_gastos_mes = (ventas_mes['Comision por venta'].fillna(0) +
                                       ventas_mes['gastos_destino'].fillna(0) +
                                       ventas_mes['Ultima_milla'].fillna(0)).sum()
                    ingreso_real_mes = total_ventas_mes - total_costo_mes - total_gastos_mes

                porcentaje_costo_mes = (total_costo_mes / total_ventas_mes * 100) if total_ventas_mes > 0 else 0
                porcentaje_ingreso_mes = (ingreso_real_mes / total_ventas_mes * 100) if total_ventas_mes > 0 else 0

                # âœ… NUEVO: Calcular ROI del mes usando la misma fÃ³rmula que la tabla
                roi_mes = (ingreso_real_mes / total_costo_mes * 100) if total_costo_mes > 0 else 0.0
            else:
                total_ventas_mes = 0
                porcentaje_costo_mes = 0
                porcentaje_ingreso_mes = 0
                ingreso_real_mes = 0
                roi_mes = 0.0

            # Agregar datos a las evoluciones (formato para JavaScript)
            fecha_formateada = f"{mes_numero:02d}/{str(aÃ±o_mes)[2:]}"  # Formato MM/YY

            evolucion_costo.append({
                'fecha': fecha_formateada,
                'porcentaje': float(porcentaje_costo_mes)
            })

            evolucion_ventas.append({
                'fecha': fecha_formateada,
                'ventas': float(total_ventas_mes)
            })

            evolucion_ingreso.append({
                'fecha': fecha_formateada,
                'porcentaje': float(porcentaje_ingreso_mes)
            })

            # âœ… NUEVO: AÃ±adir Ingreso Real nominal para grÃ¡fico de tarjeta nominal
            evolucion_ingreso_nominal.append({
                'fecha': fecha_formateada,
                'ingreso_real': float(ingreso_real_mes)
            })

            # âœ… NUEVO: AÃ±adir ROI a la evoluciÃ³n
            evolucion_roi.append({
                'fecha': fecha_formateada,
                'roi': float(roi_mes)
            })

            print(f"ðŸ“Š EvoluciÃ³n {mes_nombre} ({fecha_formateada}): Ventas=${total_ventas_mes:,.0f}, Costo={porcentaje_costo_mes:.1f}%, Ingreso={porcentaje_ingreso_mes:.1f}%, ROI={roi_mes:.1f}%")

        # Invertir para mostrar cronolÃ³gicamente (mÃ¡s antiguo primero)
        evolucion_costo.reverse()
        evolucion_ventas.reverse()
        evolucion_ingreso.reverse()
        evolucion_ingreso_nominal.reverse()
        evolucion_roi.reverse()

    except Exception as e:
        print(f"âŒ Error calculando evoluciÃ³n 3 meses: {e}")
        evolucion_costo = []
        evolucion_ventas = []
        evolucion_ingreso = []
        evolucion_ingreso_nominal = []
        evolucion_roi = []

    # Agregar campos de evoluciÃ³n al resumen
    resumen_general['evolucion_costo'] = evolucion_costo
    resumen_general['evolucion_ventas'] = evolucion_ventas
    resumen_general['evolucion_ingreso'] = evolucion_ingreso
    resumen_general['evolucion_ingreso_nominal'] = evolucion_ingreso_nominal
    resumen_general['evolucion_roi'] = evolucion_roi

    print(f"âœ… OPTIMIZADO: Resumen de rentabilidad calculado")
    print(f"âœ… Ventas: ${ventas_totales_periodo:,.0f}")
    print(f"âœ… Ingreso Real: ${ingreso_real_periodo:,.0f} ({ingreso_real_porcentaje:.1f}%)")
    print(f"âœ… ROI Promedio: {roi_promedio:.1f}%")
    print(f"âœ… EvoluciÃ³n costo: {len(evolucion_costo)} puntos")
    print(f"âœ… EvoluciÃ³n ventas: {len(evolucion_ventas)} puntos")
    print(f"âœ… EvoluciÃ³n ingreso: {len(evolucion_ingreso)} puntos")
    print(f"âœ… EvoluciÃ³n ingreso nominal: {len(evolucion_ingreso_nominal)} puntos")
    print(f"âœ… EvoluciÃ³n ROI: {len(evolucion_roi)} puntos")

    # ===== CALCULAR COMPARACIÃ“N CON MES ANTERIOR PARA ROI =====
    try:
        if df_completo is not None and not df_completo.empty:
            print("ðŸ“Š Calculando comparaciÃ³n ROI con mes anterior...")

            # Determinar mes anterior
            from datetime import date
            hoy = date.today()
            mes_actual = hoy.month
            aÃ±o_actual = hoy.year

            if mes_actual > 1:
                mes_anterior = mes_actual - 1
                aÃ±o_anterior = aÃ±o_actual
            else:
                mes_anterior = 12
                aÃ±o_anterior = aÃ±o_actual - 1

            # Preparar datos
            df_completo_naive = df_completo.copy()
            df_completo_naive["Fecha"] = pd.to_datetime(df_completo_naive["Fecha"]).dt.tz_localize(None)

            # Filtrar datos del mes anterior
            inicio_mes_anterior = pd.Timestamp(aÃ±o_anterior, mes_anterior, 1)
            if mes_anterior == 12:
                fin_mes_anterior = pd.Timestamp(aÃ±o_anterior, 12, 31)
            else:
                siguiente_mes = pd.Timestamp(aÃ±o_anterior, mes_anterior + 1, 1)
                fin_mes_anterior = siguiente_mes - pd.Timedelta(days=1)

            ventas_mes_anterior = df_completo_naive[
                (df_completo_naive["Fecha"] >= inicio_mes_anterior) &
                (df_completo_naive["Fecha"] <= fin_mes_anterior) &
                (df_completo_naive["estado"] != "Cancelado")
            ].copy()

            if not ventas_mes_anterior.empty:
                # Calcular ROI del mes anterior
                costo_anterior = float(ventas_mes_anterior["Costo de venta"].sum())
                ingreso_anterior = float(ventas_mes_anterior["Ingreso real"].sum())
                roi_anterior = (ingreso_anterior / costo_anterior * 100) if costo_anterior > 0 else 0.0

                # Calcular variaciÃ³n
                variacion_roi = roi_promedio - roi_anterior

                # Agregar campos al resumen
                resumen_general['roi_promedio_anterior'] = float(roi_anterior)
                resumen_general['variacion_roi_pct'] = float(variacion_roi)

                print(f"âœ… ROI Mes Anterior: {roi_anterior:.1f}%")
                print(f"âœ… VariaciÃ³n ROI: {variacion_roi:+.1f}pp")
            else:
                print("âš ï¸  No hay datos del mes anterior para comparar ROI")
                resumen_general['roi_promedio_anterior'] = 0.0
                resumen_general['variacion_roi_pct'] = 0.0
        else:
            print("âš ï¸  No hay datos completos disponibles para comparar ROI")
            resumen_general['roi_promedio_anterior'] = 0.0
            resumen_general['variacion_roi_pct'] = 0.0

    except Exception as e:
        print(f"âŒ Error calculando comparaciÃ³n ROI: {e}")
        resumen_general['roi_promedio_anterior'] = 0.0
        resumen_general['variacion_roi_pct'] = 0.0

    return resumen_general

def generar_datos_canales_principales(df, fecha_inicio, fecha_fin):
    """Genera datos de rentabilidad por canal principal usando la misma lÃ³gica que cumplimiento_metas"""
    import time
    import sys

    tiempo_funcion_inicio = time.time()
    print(f"ðŸ” [PERFORMANCE] INICIO - generar_datos_canales_principales()")
    sys.stdout.flush()

    if df.empty:
        return []

    print(f"INFO: Generando datos de canales principales con lÃ³gica de cumplimiento_metas")

    # Normalizar fechas del DataFrame principal
    tiempo_normalizacion_inicio = time.time()
    df_ventas_naive = df.copy()
    if 'Fecha' in df_ventas_naive.columns:
        df_ventas_naive["Fecha"] = pd.to_datetime(df_ventas_naive["Fecha"]).dt.tz_localize(None)
    tiempo_normalizacion_fin = time.time()
    print(f"â±ï¸  [PYTHON] NormalizaciÃ³n fechas: {tiempo_normalizacion_fin - tiempo_normalizacion_inicio:.3f} segundos")
    sys.stdout.flush()

    # Filtrar datos del perÃ­odo actual (excluir cancelados y filtrar por canales oficiales)
    tiempo_filtrado_inicio = time.time()
    ventas_periodo = df_ventas_naive[
        (df_ventas_naive["estado"] != "Cancelado") &
        (df_ventas_naive['Channel'].isin(CANALES_CLASIFICACION))
    ].copy()
    tiempo_filtrado_fin = time.time()
    print(f"â±ï¸  [PYTHON] Filtrado datos: {tiempo_filtrado_fin - tiempo_filtrado_inicio:.3f} segundos")
    sys.stdout.flush()

    if ventas_periodo.empty:
        print("No hay datos vÃ¡lidos para el perÃ­odo seleccionado")
        return []

    print(f"Ventas en perÃ­odo: {len(ventas_periodo)} registros")
    
    # âœ… OPTIMIZADO: Agrupar ventas por canal usando campos pre-calculados de ClickHouse
    tiempo_agrupacion_inicio = time.time()
    ventas_por_canal = ventas_periodo.groupby('Channel').agg({
        'Total': 'sum',                    # Ventas totales
        'Costo de venta': 'sum',          # Costo de venta (ya con IVA incluido)
        'Gastos_directos': 'sum',         # âœ… PRE-CALCULADO EN CLICKHOUSE
        'Ingreso real': 'sum',            # âœ… PRE-CALCULADO EN CLICKHOUSE
        'cantidad': 'sum',                # Cantidad total de unidades
        'estado': 'count'                 # Contar transacciones por canal
    }).reset_index()
    tiempo_agrupacion_fin = time.time()
    print(f"â±ï¸  [PYTHON] AgrupaciÃ³n por canal OPTIMIZADA: {tiempo_agrupacion_fin - tiempo_agrupacion_inicio:.3f} segundos")
    sys.stdout.flush()

    # Renombrar columnas para consistencia con optimizaciÃ³n
    ventas_por_canal.columns = ['Canal', 'Ventas_Reales', 'Costo_Venta', 'Gastos_Directos', 'Ingreso_Real', 'Cantidad_Total', 'Num_Transacciones']
    
    # âœ… OPTIMIZADO: Agrupar por canal y marca usando campos pre-calculados
    ventas_por_canal_marca = ventas_periodo.groupby(['Channel', 'Marca']).agg({
        'Total': 'sum',                    # Ventas totales
        'Costo de venta': 'sum',          # Costo de venta (ya con IVA)
        'Gastos_directos': 'sum',         # âœ… PRE-CALCULADO EN CLICKHOUSE
        'Ingreso real': 'sum',            # âœ… PRE-CALCULADO EN CLICKHOUSE
        'cantidad': 'sum',                # Cantidad total de unidades
        'estado': 'count'
    }).reset_index()

    ventas_por_canal_marca.columns = ['Canal', 'Marca', 'Ventas_Reales', 'Costo_Venta', 'Gastos_Directos', 'Ingreso_Real', 'Cantidad_Total', 'Num_Transacciones']

    # âœ… OPTIMIZADO: Agrupar ventas por canal, marca Y categorÃ­a usando campos pre-calculados
    ventas_por_canal_marca_categoria = ventas_periodo.groupby(['Channel', 'Marca', 'Categoria_Catalogo']).agg({
        'Total': 'sum',                    # Ventas totales
        'Costo de venta': 'sum',          # Costo de venta (ya con IVA)
        'Gastos_directos': 'sum',         # âœ… PRE-CALCULADO EN CLICKHOUSE
        'Ingreso real': 'sum',            # âœ… PRE-CALCULADO EN CLICKHOUSE
        'cantidad': 'sum',                # Cantidad total de unidades
        'estado': 'count'
    }).reset_index()

    # Renombrar columnas para consistencia con optimizaciÃ³n
    ventas_por_canal_marca_categoria.columns = ['Canal', 'Marca', 'Categoria', 'Ventas_Reales', 'Costo_Venta', 'Gastos_Directos', 'Ingreso_Real', 'Cantidad_Total', 'Num_Transacciones']

    # APLICAR IVA 16% - IGUAL QUE EN CUMPLIMIENTO_METAS
    # ventas_por_canal['Costo_Venta'] = ventas_por_canal['Costo_Venta'] * 1.16  # IVA ya incluido en los datos base
    # ventas_por_canal['Gastos_Destino'] = ventas_por_canal['Gastos_Destino'] * 1.16  # IVA ya incluido en los datos base
    # ventas_por_canal_marca['Costo_Venta'] = ventas_por_canal_marca['Costo_Venta'] * 1.16  # IVA ya incluido en los datos base
    # ventas_por_canal_marca['Gastos_Destino'] = ventas_por_canal_marca['Gastos_Destino'] * 1.16  # IVA ya incluido en los datos base
    
    # âœ… OPTIMIZADO: Los campos Gastos_Directos e Ingreso_Real ya vienen pre-calculados de ClickHouse
    print(f"âœ… OPTIMIZADO: Canal principal usando campos pre-calculados de ClickHouse")
    sys.stdout.flush()

    # Asegurar que Cantidad_Total sea numÃ©rica
    ventas_por_canal['Cantidad_Total'] = pd.to_numeric(ventas_por_canal['Cantidad_Total'], errors='coerce').fillna(0)

    # Calcular SOLO porcentajes ponderados (consistencia con totales)
    ventas_por_canal['Costo_Venta_Porcentaje'] = (
        ventas_por_canal['Costo_Venta'] / ventas_por_canal['Ventas_Reales'] * 100
    ).fillna(0)
    ventas_por_canal['Gastos_Directos_Porcentaje'] = (
        ventas_por_canal['Gastos_Directos'] / ventas_por_canal['Ventas_Reales'] * 100
    ).fillna(0)
    ventas_por_canal['Ingreso_Real_Porcentaje'] = (
        ventas_por_canal['Ingreso_Real'] / ventas_por_canal['Ventas_Reales'] * 100
    ).fillna(0)

    # âœ… NUEVO: Calcular ROI porcentaje usando mÃ©tricas agregadas
    ventas_por_canal['ROI_Porcentaje'] = (
        ventas_por_canal['Ingreso_Real'] / ventas_por_canal['Costo_Venta'] * 100
    ).fillna(0)

    # âœ… OPTIMIZADO: Calcular promedios por unidad vendida (vectorizado)
    ventas_por_canal['Ventas_Reales_Promedio'] = (ventas_por_canal['Ventas_Reales'] / ventas_por_canal['Cantidad_Total']).fillna(0)
    ventas_por_canal['Costo_Venta_Promedio'] = (ventas_por_canal['Costo_Venta'] / ventas_por_canal['Cantidad_Total']).fillna(0)
    ventas_por_canal['Gastos_Directos_Promedio'] = (ventas_por_canal['Gastos_Directos'] / ventas_por_canal['Cantidad_Total']).fillna(0)
    ventas_por_canal['Ingreso_Real_Promedio'] = (ventas_por_canal['Ingreso_Real'] / ventas_por_canal['Cantidad_Total']).fillna(0)
    
    # âœ… OPTIMIZADO: Canal + Marca - usar campos pre-calculados
    ventas_por_canal_marca['Cantidad_Total'] = pd.to_numeric(ventas_por_canal_marca['Cantidad_Total'], errors='coerce').fillna(0)

    # Calcular SOLO porcentajes ponderados (consistencia con totales)
    ventas_por_canal_marca['Costo_Venta_Porcentaje'] = (
        ventas_por_canal_marca['Costo_Venta'] / ventas_por_canal_marca['Ventas_Reales'] * 100
    ).fillna(0)
    ventas_por_canal_marca['Gastos_Directos_Porcentaje'] = (
        ventas_por_canal_marca['Gastos_Directos'] / ventas_por_canal_marca['Ventas_Reales'] * 100
    ).fillna(0)
    ventas_por_canal_marca['Ingreso_Real_Porcentaje'] = (
        ventas_por_canal_marca['Ingreso_Real'] / ventas_por_canal_marca['Ventas_Reales'] * 100
    ).fillna(0)

    # âœ… NUEVO: Calcular ROI porcentaje para Canal + Marca
    ventas_por_canal_marca['ROI_Porcentaje'] = (
        ventas_por_canal_marca['Ingreso_Real'] / ventas_por_canal_marca['Costo_Venta'] * 100
    ).fillna(0)

    # âœ… OPTIMIZADO: Calcular promedios por unidad vendida (vectorizado)
    ventas_por_canal_marca['Ventas_Reales_Promedio'] = (ventas_por_canal_marca['Ventas_Reales'] / ventas_por_canal_marca['Cantidad_Total']).fillna(0)
    ventas_por_canal_marca['Costo_Venta_Promedio'] = (ventas_por_canal_marca['Costo_Venta'] / ventas_por_canal_marca['Cantidad_Total']).fillna(0)
    ventas_por_canal_marca['Gastos_Directos_Promedio'] = (ventas_por_canal_marca['Gastos_Directos'] / ventas_por_canal_marca['Cantidad_Total']).fillna(0)
    ventas_por_canal_marca['Ingreso_Real_Promedio'] = (ventas_por_canal_marca['Ingreso_Real'] / ventas_por_canal_marca['Cantidad_Total']).fillna(0)

    # âœ… OPTIMIZADO: Canal + Marca + CategorÃ­a - usar campos pre-calculados (ya no se calculan mÃ©tricas derivadas)

    # Asegurar que Cantidad_Total sea numÃ©rica
    ventas_por_canal_marca_categoria['Cantidad_Total'] = pd.to_numeric(ventas_por_canal_marca_categoria['Cantidad_Total'], errors='coerce').fillna(0)

    # âœ… OPTIMIZADO: Calcular PRECIO PROMEDIO POR UNIDAD por canal, marca y categorÃ­a (vectorizado)
    ventas_por_canal_marca_categoria['Ventas_Reales_Promedio'] = (ventas_por_canal_marca_categoria['Ventas_Reales'] / ventas_por_canal_marca_categoria['Cantidad_Total']).fillna(0)
    ventas_por_canal_marca_categoria['Costo_Venta_Promedio'] = (ventas_por_canal_marca_categoria['Costo_Venta'] / ventas_por_canal_marca_categoria['Cantidad_Total']).fillna(0)
    ventas_por_canal_marca_categoria['Gastos_Directos_Promedio'] = (ventas_por_canal_marca_categoria['Gastos_Directos'] / ventas_por_canal_marca_categoria['Cantidad_Total']).fillna(0)
    ventas_por_canal_marca_categoria['Ingreso_Real_Promedio'] = (ventas_por_canal_marca_categoria['Ingreso_Real'] / ventas_por_canal_marca_categoria['Cantidad_Total']).fillna(0)

    # Calcular PORCENTAJES POR CANAL, MARCA Y CATEGORÃA
    ventas_por_canal_marca_categoria['Costo_Venta_Porcentaje'] = (ventas_por_canal_marca_categoria['Costo_Venta'] / ventas_por_canal_marca_categoria['Ventas_Reales'] * 100).fillna(0)
    ventas_por_canal_marca_categoria['Gastos_Directos_Porcentaje'] = (ventas_por_canal_marca_categoria['Gastos_Directos'] / ventas_por_canal_marca_categoria['Ventas_Reales'] * 100).fillna(0)
    ventas_por_canal_marca_categoria['Ingreso_Real_Porcentaje'] = (ventas_por_canal_marca_categoria['Ingreso_Real'] / ventas_por_canal_marca_categoria['Ventas_Reales'] * 100).fillna(0)

    # âœ… NUEVO: Calcular ROI porcentaje para Canal + Marca + CategorÃ­a
    ventas_por_canal_marca_categoria['ROI_Porcentaje'] = (
        ventas_por_canal_marca_categoria['Ingreso_Real'] / ventas_por_canal_marca_categoria['Costo_Venta'] * 100
    ).fillna(0)
    
    # ====== COMPARACIÃ“N CON MES ANTERIOR - LÃ“GICA EXACTA DE CUMPLIMIENTO_METAS ======
    print("=== CALCULANDO VARIACIÃ“N CON MES ANTERIOR ===")
    
    from datetime import date
    
    # Convertir fechas
    f1_naive = pd.to_datetime(fecha_inicio).tz_localize(None) if isinstance(fecha_inicio, str) else fecha_inicio
    f2_naive = pd.to_datetime(fecha_fin).tz_localize(None) if isinstance(fecha_fin, str) else fecha_fin
    
    # Determinar el perÃ­odo de comparaciÃ³n basado en dÃ­as transcurridos
    hoy = date.today()
    mes_actual = f1_naive.month
    aÃ±o_actual = f1_naive.year
    
    # Calcular dÃ­as transcurridos del perÃ­odo actual
    if mes_actual == hoy.month and aÃ±o_actual == hoy.year:
        dia_actual = min(hoy.day, f2_naive.day)
        dias_transcurridos = dia_actual

        if mes_actual > 1:
            mes_anterior = mes_actual - 1
            aÃ±o_anterior = aÃ±o_actual
        else:
            mes_anterior = 12
            aÃ±o_anterior = aÃ±o_actual - 1

        f1_anterior = pd.Timestamp(aÃ±o_anterior, mes_anterior, 1)
        f2_anterior = pd.Timestamp(aÃ±o_anterior, mes_anterior, dia_actual)
        periodo_comparacion = f"vs mismos {dias_transcurridos} dÃ­as de {f1_anterior.strftime('%B %Y')}"

    else:
        dias_transcurridos = (f2_naive - f1_naive).days + 1
        
        if mes_actual > 1:
            mes_anterior = mes_actual - 1
            aÃ±o_anterior = aÃ±o_actual
        else:
            mes_anterior = 12
            aÃ±o_anterior = aÃ±o_actual - 1
        
        f1_anterior = pd.Timestamp(aÃ±o_anterior, mes_anterior, 1)
        if mes_anterior == 12:
            f2_anterior = pd.Timestamp(aÃ±o_anterior, 12, 31)
        else:
            siguiente_mes = pd.Timestamp(aÃ±o_anterior, mes_anterior + 1, 1)
            f2_anterior = siguiente_mes - pd.Timedelta(days=1)
        
        periodo_comparacion = f"vs {f1_anterior.strftime('%B %Y')} completo"
    
    print(f"PerÃ­odo actual: {f1_naive.date()} al {f2_naive.date()}")
    print(f"PerÃ­odo anterior: {f1_anterior.date()} al {f2_anterior.date()}")
    print(f"DescripciÃ³n: {periodo_comparacion}")
    
    # Inicializar DataFrames para datos del mes anterior
    ventas_por_canal_anterior = pd.DataFrame()
    ventas_por_canal_marca_anterior = pd.DataFrame()
    ventas_por_canal_marca_categoria_anterior = pd.DataFrame()
    
    try:
        print(f"Cargando datos optimizados para comparaciÃ³n: {mes_actual}/{aÃ±o_actual} vs {mes_anterior}/{aÃ±o_anterior}")
        tiempo_comparacion_inicio = time.time()
        df_ventas_comparacion, _, _ = load_data_improved(
            mes_filtro=mes_actual,
            incluir_comparacion=True,
            aÃ±o_especifico=aÃ±o_actual
        )
        tiempo_comparacion_fin = time.time()
        print(f"â±ï¸  [PYTHON] Carga datos comparaciÃ³n: {tiempo_comparacion_fin - tiempo_comparacion_inicio:.3f} segundos")
        sys.stdout.flush()
        
        if not df_ventas_comparacion.empty:
            # Normalizar fechas
            df_ventas_comparacion_naive = df_ventas_comparacion.copy()
            df_ventas_comparacion_naive["Fecha"] = df_ventas_comparacion_naive["Fecha"].dt.tz_localize(None)
            
            # Filtrar solo datos del mes anterior del dataset completo
            ventas_periodo_anterior = df_ventas_comparacion_naive[
                (df_ventas_comparacion_naive["Fecha"] >= f1_anterior) &
                (df_ventas_comparacion_naive["Fecha"] <= f2_anterior) &
                (df_ventas_comparacion_naive["estado"] != "Cancelado") &
                (df_ventas_comparacion_naive['Channel'].isin(CANALES_CLASIFICACION))
            ].copy()
            
            print(f"âœ… OPTIMIZADO: {len(ventas_periodo_anterior)} registros del perÃ­odo anterior obtenidos en una sola query")
            
            if not ventas_periodo_anterior.empty:
                # âœ… OPTIMIZADO: Calcular mÃ©tricas por canal del mes anterior usando campos pre-calculados
                ventas_por_canal_anterior = ventas_periodo_anterior.groupby('Channel').agg({
                    'Total': 'sum',                    # Ventas totales
                    'Costo de venta': 'sum',          # Costo de venta (ya con IVA)
                    'Gastos_directos': 'sum',         # âœ… PRE-CALCULADO EN CLICKHOUSE
                    'Ingreso real': 'sum',            # âœ… PRE-CALCULADO EN CLICKHOUSE
                    'cantidad': 'sum',                # Cantidad total de unidades
                    'estado': 'count'
                }).reset_index()

                ventas_por_canal_anterior.columns = ['Canal', 'Ventas_Reales', 'Costo_Venta', 'Gastos_Directos', 'Ingreso_Real', 'Cantidad_Total', 'Num_Transacciones']
                
                # Aplicar IVA y calcular mÃ©tricas derivadas (mismo proceso)
                # ventas_por_canal_anterior['Costo_Venta'] = ventas_por_canal_anterior['Costo_Venta'] * 1.16  # IVA ya incluido en los datos base
                # ventas_por_canal_anterior['Gastos_Destino'] = ventas_por_canal_anterior['Gastos_Destino'] * 1.16  # IVA ya incluido en los datos base
                # âœ… OPTIMIZADO: Solo calcular porcentajes (campos ya pre-calculados)
                ventas_por_canal_anterior['Cantidad_Total'] = pd.to_numeric(ventas_por_canal_anterior['Cantidad_Total'], errors='coerce').fillna(0)

                # Calcular SOLO porcentajes ponderados
                ventas_por_canal_anterior['Costo_Venta_Porcentaje'] = (
                    ventas_por_canal_anterior['Costo_Venta'] / ventas_por_canal_anterior['Ventas_Reales'] * 100
                ).fillna(0)
                ventas_por_canal_anterior['Gastos_Directos_Porcentaje'] = (
                    ventas_por_canal_anterior['Gastos_Directos'] / ventas_por_canal_anterior['Ventas_Reales'] * 100
                ).fillna(0)
                ventas_por_canal_anterior['Ingreso_Real_Porcentaje'] = (
                    ventas_por_canal_anterior['Ingreso_Real'] / ventas_por_canal_anterior['Ventas_Reales'] * 100
                ).fillna(0)

                # âœ… NUEVO: Calcular ROI porcentaje para datos del mes anterior
                ventas_por_canal_anterior['ROI_Porcentaje'] = (
                    ventas_por_canal_anterior['Ingreso_Real'] / ventas_por_canal_anterior['Costo_Venta'] * 100
                ).fillna(0)

                # âœ… OPTIMIZADO: Calcular mÃ©tricas por canal y marca del mes anterior usando campos pre-calculados
                ventas_por_canal_marca_anterior = ventas_periodo_anterior.groupby(['Channel', 'Marca']).agg({
                    'Total': 'sum',                    # Ventas totales
                    'Costo de venta': 'sum',          # Costo de venta (ya con IVA)
                    'Gastos_directos': 'sum',         # âœ… PRE-CALCULADO EN CLICKHOUSE
                    'Ingreso real': 'sum',            # âœ… PRE-CALCULADO EN CLICKHOUSE
                    'cantidad': 'sum',                # Cantidad total de unidades
                    'estado': 'count'
                }).reset_index()

                ventas_por_canal_marca_anterior.columns = ['Canal', 'Marca', 'Ventas_Reales', 'Costo_Venta', 'Gastos_Directos', 'Ingreso_Real', 'Cantidad_Total', 'Num_Transacciones']
                
                # Aplicar mismos cÃ¡lculos
                # ventas_por_canal_marca_anterior['Costo_Venta'] = ventas_por_canal_marca_anterior['Costo_Venta'] * 1.16  # IVA ya incluido en los datos base
                # ventas_por_canal_marca_anterior['Gastos_Destino'] = ventas_por_canal_marca_anterior['Gastos_Destino'] * 1.16  # IVA ya incluido en los datos base
                # âœ… OPTIMIZADO: Solo calcular porcentajes (campos ya pre-calculados)
                ventas_por_canal_marca_anterior['Cantidad_Total'] = pd.to_numeric(ventas_por_canal_marca_anterior['Cantidad_Total'], errors='coerce').fillna(0)

                # Calcular SOLO porcentajes ponderados
                ventas_por_canal_marca_anterior['Costo_Venta_Porcentaje'] = (
                    ventas_por_canal_marca_anterior['Costo_Venta'] / ventas_por_canal_marca_anterior['Ventas_Reales'] * 100
                ).fillna(0)
                ventas_por_canal_marca_anterior['Gastos_Directos_Porcentaje'] = (
                    ventas_por_canal_marca_anterior['Gastos_Directos'] / ventas_por_canal_marca_anterior['Ventas_Reales'] * 100
                ).fillna(0)
                ventas_por_canal_marca_anterior['Ingreso_Real_Porcentaje'] = (
                    ventas_por_canal_marca_anterior['Ingreso_Real'] / ventas_por_canal_marca_anterior['Ventas_Reales'] * 100
                ).fillna(0)

                # âœ… NUEVO: Calcular ROI porcentaje para mes anterior
                ventas_por_canal_marca_anterior['ROI_Porcentaje'] = (
                    ventas_por_canal_marca_anterior['Ingreso_Real'] / ventas_por_canal_marca_anterior['Costo_Venta'] * 100
                ).fillna(0)
                
                # âœ… OPTIMIZADO: Calcular mÃ©tricas por canal, marca Y categorÃ­a del mes anterior usando campos pre-calculados
                ventas_por_canal_marca_categoria_anterior = ventas_periodo_anterior.groupby(['Channel', 'Marca', 'Categoria_Catalogo']).agg({
                    'Total': 'sum',                    # Ventas totales
                    'Costo de venta': 'sum',          # Costo de venta (ya con IVA)
                    'Gastos_directos': 'sum',         # âœ… PRE-CALCULADO EN CLICKHOUSE
                    'Ingreso real': 'sum',            # âœ… PRE-CALCULADO EN CLICKHOUSE
                    'cantidad': 'sum',                # Cantidad total de unidades
                    'estado': 'count'
                }).reset_index()

                ventas_por_canal_marca_categoria_anterior.columns = ['Canal', 'Marca', 'Categoria', 'Ventas_Reales', 'Costo_Venta', 'Gastos_Directos', 'Ingreso_Real', 'Cantidad_Total', 'Num_Transacciones']

                # Aplicar mismo procesamiento que a los datos actuales
                # ventas_por_canal_marca_categoria_anterior['Costo_Venta'] = ventas_por_canal_marca_categoria_anterior['Costo_Venta'] * 1.16  # IVA ya incluido en los datos base
                # ventas_por_canal_marca_categoria_anterior['Gastos_Destino'] = ventas_por_canal_marca_categoria_anterior['Gastos_Destino'] * 1.16  # IVA ya incluido en los datos base
                # âœ… OPTIMIZADO: Solo calcular porcentajes (campos ya pre-calculados)
                ventas_por_canal_marca_categoria_anterior['Cantidad_Total'] = pd.to_numeric(ventas_por_canal_marca_categoria_anterior['Cantidad_Total'], errors='coerce').fillna(0)

                # Calcular SOLO porcentajes ponderados
                ventas_por_canal_marca_categoria_anterior['Costo_Venta_Porcentaje'] = (
                    ventas_por_canal_marca_categoria_anterior['Costo_Venta'] / ventas_por_canal_marca_categoria_anterior['Ventas_Reales'] * 100
                ).fillna(0)
                ventas_por_canal_marca_categoria_anterior['Gastos_Directos_Porcentaje'] = (
                    ventas_por_canal_marca_categoria_anterior['Gastos_Directos'] / ventas_por_canal_marca_categoria_anterior['Ventas_Reales'] * 100
                ).fillna(0)
                ventas_por_canal_marca_categoria_anterior['Ingreso_Real_Porcentaje'] = (
                    ventas_por_canal_marca_categoria_anterior['Ingreso_Real'] / ventas_por_canal_marca_categoria_anterior['Ventas_Reales'] * 100
                ).fillna(0)

                # âœ… NUEVO: Calcular ROI porcentaje para categorÃ­as mes anterior
                ventas_por_canal_marca_categoria_anterior['ROI_Porcentaje'] = (
                    ventas_por_canal_marca_categoria_anterior['Ingreso_Real'] / ventas_por_canal_marca_categoria_anterior['Costo_Venta'] * 100
                ).fillna(0)

                print(f"Canales en mes anterior: {len(ventas_por_canal_anterior)}")
                print(f"CategorÃ­as en mes anterior: {len(ventas_por_canal_marca_categoria_anterior)}")
            else:
                print("No hay datos vÃ¡lidos para el perÃ­odo anterior")
        else:
            print("âš ï¸  No se pudieron cargar datos de comparaciÃ³n - usando query optimizada individual")
            # Fallback: intentar carga individual del mes anterior
            try:
                df_fallback, _, _ = load_data_improved(mes_filtro=mes_anterior, aÃ±o_especifico=aÃ±o_anterior)
                if not df_fallback.empty:
                    df_fallback_naive = df_fallback.copy()
                    df_fallback_naive["Fecha"] = df_fallback_naive["Fecha"].dt.tz_localize(None)
                    
                    ventas_periodo_anterior = df_fallback_naive[
                        (df_fallback_naive["Fecha"] >= f1_anterior) &
                        (df_fallback_naive["Fecha"] <= f2_anterior) &
                        (df_fallback_naive["estado"] != "Cancelado") &
                        (df_fallback_naive['Channel'].isin(CANALES_CLASIFICACION))
                    ].copy()
                    
                    if not ventas_periodo_anterior.empty:
                        # âœ… FALLBACK: Intentar usar campos pre-calculados si estÃ¡n disponibles
                        try:
                            # Intentar primero con campos optimizados
                            ventas_por_canal_anterior = ventas_periodo_anterior.groupby('Channel').agg({
                                'Total': 'sum',                    # Ventas totales
                                'Costo de venta': 'sum',          # Costo de venta (ya con IVA)
                                'Gastos_directos': 'sum',         # âœ… PRE-CALCULADO EN CLICKHOUSE
                                'Ingreso real': 'sum',            # âœ… PRE-CALCULADO EN CLICKHOUSE
                                'cantidad': 'sum',                # Cantidad total de unidades
                                'estado': 'count'
                            }).reset_index()

                            ventas_por_canal_anterior.columns = ['Canal', 'Ventas_Reales', 'Costo_Venta', 'Gastos_Directos', 'Ingreso_Real', 'Cantidad_Total', 'Num_Transacciones']
                        except:
                            # Fallback a cÃ¡lculo manual si no estÃ¡n los campos pre-calculados
                            ventas_por_canal_anterior = ventas_periodo_anterior.groupby('Channel').agg({
                                'Total': 'sum',
                                'Costo de venta': 'sum',
                                'Comision por venta': 'sum',
                                'gastos_destino': 'sum',
                                'Ultima_milla': 'sum',
                                'estado': 'count'
                            }).reset_index()

                            ventas_por_canal_anterior.columns = ['Canal', 'Ventas_Reales', 'Costo_Venta', 'Comision_Venta', 'Gastos_Destino', 'Ultima_Milla', 'Num_Transacciones']
                            ventas_por_canal_anterior['Gastos_Directos'] = ventas_por_canal_anterior['Comision_Venta'] + ventas_por_canal_anterior['Gastos_Destino'] + ventas_por_canal_anterior['Ultima_Milla']
                            ventas_por_canal_anterior['Ingreso_Real'] = ventas_por_canal_anterior['Ventas_Reales'] - ventas_por_canal_anterior['Costo_Venta'] - ventas_por_canal_anterior['Gastos_Directos']

                        ventas_por_canal_anterior['Ingreso_Real_Porcentaje'] = (ventas_por_canal_anterior['Ingreso_Real'] / ventas_por_canal_anterior['Ventas_Reales'] * 100).fillna(0)

                        # âœ… NUEVO: Calcular porcentajes faltantes para datos del mes anterior
                        ventas_por_canal_anterior['Costo_Venta_Porcentaje'] = (ventas_por_canal_anterior['Costo_Venta'] / ventas_por_canal_anterior['Ventas_Reales'] * 100).fillna(0)
                        ventas_por_canal_anterior['Gastos_Directos_Porcentaje'] = (ventas_por_canal_anterior['Gastos_Directos'] / ventas_por_canal_anterior['Ventas_Reales'] * 100).fillna(0)
                        ventas_por_canal_anterior['ROI_Porcentaje'] = (ventas_por_canal_anterior['Ingreso_Real'] / ventas_por_canal_anterior['Costo_Venta'] * 100).fillna(0)

                        # âœ… FALLBACK: TambiÃ©n calcular categorÃ­as con campos optimizados si estÃ¡n disponibles
                        try:
                            # Intentar primero con campos optimizados
                            ventas_por_canal_marca_categoria_anterior = ventas_periodo_anterior.groupby(['Channel', 'Marca', 'Categoria_Catalogo']).agg({
                                'Total': 'sum',                    # Ventas totales
                                'Costo de venta': 'sum',          # Costo de venta (ya con IVA)
                                'Gastos_directos': 'sum',         # âœ… PRE-CALCULADO EN CLICKHOUSE
                                'Ingreso real': 'sum',            # âœ… PRE-CALCULADO EN CLICKHOUSE
                                'cantidad': 'sum',                # Cantidad total de unidades
                                'estado': 'count'
                            }).reset_index()

                            ventas_por_canal_marca_categoria_anterior.columns = ['Canal', 'Marca', 'Categoria', 'Ventas_Reales', 'Costo_Venta', 'Gastos_Directos', 'Ingreso_Real', 'Cantidad_Total', 'Num_Transacciones']
                        except:
                            # Fallback a cÃ¡lculo manual si no estÃ¡n los campos pre-calculados
                            ventas_por_canal_marca_categoria_anterior = ventas_periodo_anterior.groupby(['Channel', 'Marca', 'Categoria_Catalogo']).agg({
                                'Total': 'sum',
                                'Costo de venta': 'sum',
                                'Comision por venta': 'sum',
                                'gastos_destino': 'sum',
                                'Ultima_milla': 'sum',
                                'estado': 'count'
                            }).reset_index()

                            ventas_por_canal_marca_categoria_anterior.columns = ['Canal', 'Marca', 'Categoria', 'Ventas_Reales', 'Costo_Venta', 'Comision_Venta', 'Gastos_Destino', 'Ultima_Milla', 'Num_Transacciones']
                            ventas_por_canal_marca_categoria_anterior['Gastos_Directos'] = ventas_por_canal_marca_categoria_anterior['Comision_Venta'] + ventas_por_canal_marca_categoria_anterior['Gastos_Destino'] + ventas_por_canal_marca_categoria_anterior['Ultima_Milla']
                            ventas_por_canal_marca_categoria_anterior['Ingreso_Real'] = ventas_por_canal_marca_categoria_anterior['Ventas_Reales'] - ventas_por_canal_marca_categoria_anterior['Costo_Venta'] - ventas_por_canal_marca_categoria_anterior['Gastos_Directos']

                        ventas_por_canal_marca_categoria_anterior['Ingreso_Real_Porcentaje'] = (ventas_por_canal_marca_categoria_anterior['Ingreso_Real'] / ventas_por_canal_marca_categoria_anterior['Ventas_Reales'] * 100).fillna(0)

                        # âœ… NUEVO: Calcular ROI porcentaje para categorÃ­as mes anterior (fallback)
                        ventas_por_canal_marca_categoria_anterior['ROI_Porcentaje'] = (ventas_por_canal_marca_categoria_anterior['Ingreso_Real'] / ventas_por_canal_marca_categoria_anterior['Costo_Venta'] * 100).fillna(0)

                        print(f"âœ… FALLBACK: {len(ventas_periodo_anterior)} registros obtenidos con query individual")
                        print(f"âœ… FALLBACK: {len(ventas_por_canal_marca_categoria_anterior)} categorÃ­as del mes anterior")
            except Exception as ef:
                print(f"âŒ Fallback tambiÃ©n fallÃ³: {ef}")
                
    except Exception as e:
        print(f"âŒ Error en carga optimizada de comparaciÃ³n: {e}")
    
    # Agregar datos de comparaciÃ³n a los DataFrames principales - LÃ“GICA EXACTA DE CUMPLIMIENTO_METAS
    if not ventas_por_canal_anterior.empty:
        # ðŸ” DEBUG: Verificar quÃ© columnas tiene ventas_por_canal_anterior
        print(f"ðŸ” DEBUG: Columnas en ventas_por_canal_anterior: {list(ventas_por_canal_anterior.columns)}")

        # Merge para obtener porcentajes del mes anterior
        ventas_por_canal = pd.merge(
            ventas_por_canal,
            ventas_por_canal_anterior[['Canal', 'Ingreso_Real', 'Ingreso_Real_Porcentaje', 'Ventas_Reales', 'Costo_Venta', 'Costo_Venta_Porcentaje', 'Gastos_Directos', 'Gastos_Directos_Porcentaje', 'ROI_Porcentaje']].rename(columns={
                'Ingreso_Real': 'Ingreso_Real_Anterior',
                'Ingreso_Real_Porcentaje': 'Ingreso_Real_Porcentaje_Anterior',
                'Ventas_Reales': 'Ventas_Reales_Anterior',
                'Costo_Venta': 'Costo_Venta_Anterior',
                'Costo_Venta_Porcentaje': 'Costo_Venta_Porcentaje_Anterior',
                'Gastos_Directos': 'Gastos_Directos_Anterior',
                'Gastos_Directos_Porcentaje': 'Gastos_Directos_Porcentaje_Anterior',
                'ROI_Porcentaje': 'ROI_Porcentaje_Anterior'
            }),
            on='Canal',
            how='left'
        )
        
        # Calcular variaciÃ³n NOMINAL del ingreso real (comparando montos en dinero)
        ingreso_real_anterior = ventas_por_canal['Ingreso_Real_Anterior'].fillna(0)
        ventas_por_canal['Variacion_Ingreso_Pct'] = (
            (ventas_por_canal['Ingreso_Real'] - ingreso_real_anterior) /
            ingreso_real_anterior.abs().replace(0, 1) * 100
        ).fillna(0)

        # Calcular variaciÃ³n en PUNTOS PORCENTUALES del % ingreso real
        ventas_por_canal['Variacion_Ingreso_Porcentaje_Pct'] = (
            ventas_por_canal['Ingreso_Real_Porcentaje'] -
            ventas_por_canal['Ingreso_Real_Porcentaje_Anterior'].fillna(0)
        )

        # Calcular variaciÃ³n porcentual de ventas vs mes anterior
        ventas_por_canal['Variacion_Ventas_Pct'] = (
            (ventas_por_canal['Ventas_Reales'] - ventas_por_canal['Ventas_Reales_Anterior'].fillna(0)) /
            ventas_por_canal['Ventas_Reales_Anterior'].fillna(1) * 100
        ).fillna(0)

        # Calcular variaciÃ³n de porcentaje de costo de venta vs mes anterior (puntos porcentuales)
        ventas_por_canal['Variacion_Costo_Venta_Pct'] = (
            ventas_por_canal['Costo_Venta_Porcentaje'] - ventas_por_canal['Costo_Venta_Porcentaje_Anterior'].fillna(0)
        ).fillna(0)

        # Calcular variaciÃ³n de porcentaje de gastos directos vs mes anterior (puntos porcentuales)
        ventas_por_canal['Variacion_Gastos_Directos_Pct'] = (
            ventas_por_canal['Gastos_Directos_Porcentaje'] - ventas_por_canal['Gastos_Directos_Porcentaje_Anterior'].fillna(0)
        ).fillna(0)

        # âœ… NUEVO: Calcular variaciÃ³n de ROI vs mes anterior (puntos porcentuales)
        ventas_por_canal['Variacion_ROI_Pct'] = (
            ventas_por_canal['ROI_Porcentaje'] - ventas_por_canal['ROI_Porcentaje_Anterior'].fillna(0)
        ).fillna(0)

        # Agregar informaciÃ³n del perÃ­odo
        ventas_por_canal['Periodo_Comparacion'] = periodo_comparacion
        ventas_por_canal['Dias_Comparados'] = dias_transcurridos
        
        print("âœ… Variaciones calculadas exitosamente")
    else:
        # Sin datos de comparaciÃ³n
        ventas_por_canal['Ingreso_Real_Anterior'] = 0
        ventas_por_canal['Ingreso_Real_Porcentaje_Anterior'] = 0
        ventas_por_canal['Ventas_Reales_Anterior'] = 0
        ventas_por_canal['Costo_Venta_Anterior'] = 0
        ventas_por_canal['Costo_Venta_Porcentaje_Anterior'] = 0
        ventas_por_canal['ROI_Porcentaje_Anterior'] = 0
        ventas_por_canal['Variacion_Ingreso_Pct'] = 0
        ventas_por_canal['Variacion_Ingreso_Porcentaje_Pct'] = 0
        ventas_por_canal['Variacion_Ventas_Pct'] = 0
        ventas_por_canal['Variacion_Costo_Venta_Pct'] = 0
        ventas_por_canal['Variacion_Gastos_Directos_Pct'] = 0
        ventas_por_canal['Variacion_ROI_Pct'] = 0
        ventas_por_canal['Periodo_Comparacion'] = "Sin datos del perÃ­odo anterior"
        ventas_por_canal['Dias_Comparados'] = 0
        print("âš ï¸  Sin datos para comparaciÃ³n temporal")
    
    # Convertir los DataFrames de pandas a lista de diccionarios como en cumplimiento_metas
    canales_data = []
    
    # Definir los canales principales
    CANALES_PRINCIPALES = [
        'Mercado Libre', 'CrediTienda', 'Walmart', 
        'Shein', 'Liverpool', 'Yuhu', 
        'Aliexpress', 'Coppel'
    ]
    
    # DEBUG: Mostrar variaciones de canales principales
    print("=== VARIACIONES POR CANAL PRINCIPAL ===")
    for _, canal in ventas_por_canal.iterrows():
        variacion_ingreso = canal.get('Variacion_Ingreso_Pct', 0)
        if variacion_ingreso != 0:
            signo = "+" if variacion_ingreso > 0 else ""
            ingreso_anterior = canal.get('Ingreso_Real_Porcentaje_Anterior', 0)
            print(f"âœ“ {canal['Canal']}: {canal['Ingreso_Real_Porcentaje']:.1f}% "
                  f"(anterior: {ingreso_anterior:.1f}%) = "
                  f"{signo}{variacion_ingreso:.1f}pp "
                  f"({canal['Num_Transacciones']} trans)")
        else:
            print(f"âš  {canal['Canal']}: {canal['Ingreso_Real_Porcentaje']:.1f}% (sin datos anteriores)")
    
    # Generar datos para cada canal principal - SIGUIENDO ESTRUCTURA DE CUMPLIMIENTO_METAS
    for canal_nombre in CANALES_PRINCIPALES:
        # Buscar datos del canal en el DataFrame
        canal_row = ventas_por_canal[ventas_por_canal['Canal'] == canal_nombre]
        
        if not canal_row.empty:
            # Canal con datos
            row = canal_row.iloc[0]
            
            # Calcular porcentajes que faltan si no existen
            ventas = float(row['Ventas_Reales']) if 'Ventas_Reales' in row and pd.notna(row['Ventas_Reales']) else 0
            costo = float(row['Costo_Venta']) if 'Costo_Venta' in row and pd.notna(row['Costo_Venta']) else 0
            gastos = float(row['Gastos_Directos']) if 'Gastos_Directos' in row and pd.notna(row['Gastos_Directos']) else 0
            
            costo_pct = (costo / ventas * 100) if ventas > 0 else 0
            gastos_pct = (gastos / ventas * 100) if ventas > 0 else 0
            
            canal_data = {
                'canal': canal_nombre,
                'es_fila_principal': True,
                'es_subfila': False,
                'ventas_reales': ventas,
                'costo_venta': costo,
                'gastos_directos': gastos,
                'ingreso_real': float(row['Ingreso_Real']) if 'Ingreso_Real' in row and pd.notna(row['Ingreso_Real']) else 0,
                'costo_venta_porcentaje': costo_pct,
                'gastos_directos_porcentaje': gastos_pct,
                'ingreso_real_porcentaje': float(row['Ingreso_Real_Porcentaje']) if 'Ingreso_Real_Porcentaje' in row and pd.notna(row['Ingreso_Real_Porcentaje']) else 0,
                'roi_porcentaje': float(row['ROI_Porcentaje']) if 'ROI_Porcentaje' in row and pd.notna(row['ROI_Porcentaje']) else 0,
                'num_transacciones': int(row['Num_Transacciones']) if 'Num_Transacciones' in row and pd.notna(row['Num_Transacciones']) else 0,
                'ventas_reales_promedio': float(row['Ventas_Reales_Promedio']) if 'Ventas_Reales_Promedio' in row and pd.notna(row['Ventas_Reales_Promedio']) else 0,
                'costo_venta_promedio': float(row['Costo_Venta_Promedio']) if 'Costo_Venta_Promedio' in row and pd.notna(row['Costo_Venta_Promedio']) else 0,
                'gastos_directos_promedio': float(row['Gastos_Directos_Promedio']) if 'Gastos_Directos_Promedio' in row and pd.notna(row['Gastos_Directos_Promedio']) else 0,
                'ingreso_real_promedio': float(row['Ingreso_Real_Promedio']) if 'Ingreso_Real_Promedio' in row and pd.notna(row['Ingreso_Real_Promedio']) else 0,
                # CAMPOS DE COMPARACIÃ“N CON MES ANTERIOR
                'ingreso_real_porcentaje_anterior': float(row['Ingreso_Real_Porcentaje_Anterior']) if 'Ingreso_Real_Porcentaje_Anterior' in row and pd.notna(row['Ingreso_Real_Porcentaje_Anterior']) else 0,
                'variacion_ingreso_pct': float(row['Variacion_Ingreso_Pct']) if 'Variacion_Ingreso_Pct' in row and pd.notna(row['Variacion_Ingreso_Pct']) else 0,  # VariaciÃ³n nominal del monto
                'variacion_ingreso_porcentaje_pct': float(row['Variacion_Ingreso_Porcentaje_Pct']) if 'Variacion_Ingreso_Porcentaje_Pct' in row and pd.notna(row['Variacion_Ingreso_Porcentaje_Pct']) else 0,  # VariaciÃ³n pp del %
                'ventas_reales_anterior': float(row['Ventas_Reales_Anterior']) if 'Ventas_Reales_Anterior' in row and pd.notna(row['Ventas_Reales_Anterior']) else 0,
                'variacion_ventas_pct': float(row['Variacion_Ventas_Pct']) if 'Variacion_Ventas_Pct' in row and pd.notna(row['Variacion_Ventas_Pct']) else 0,
                'costo_venta_anterior': float(row['Costo_Venta_Anterior']) if 'Costo_Venta_Anterior' in row and pd.notna(row['Costo_Venta_Anterior']) else 0,
                'costo_venta_porcentaje_anterior': float(row['Costo_Venta_Porcentaje_Anterior']) if 'Costo_Venta_Porcentaje_Anterior' in row and pd.notna(row['Costo_Venta_Porcentaje_Anterior']) else 0,
                'variacion_costo_venta_pct': float(row['Variacion_Costo_Venta_Pct']) if 'Variacion_Costo_Venta_Pct' in row and pd.notna(row['Variacion_Costo_Venta_Pct']) else 0,
                'gastos_directos_anterior': float(row['Gastos_Directos_Anterior']) if 'Gastos_Directos_Anterior' in row and pd.notna(row['Gastos_Directos_Anterior']) else 0,
                'gastos_directos_porcentaje_anterior': float(row['Gastos_Directos_Porcentaje_Anterior']) if 'Gastos_Directos_Porcentaje_Anterior' in row and pd.notna(row['Gastos_Directos_Porcentaje_Anterior']) else 0,
                'variacion_gastos_directos_pct': float(row['Variacion_Gastos_Directos_Pct']) if 'Variacion_Gastos_Directos_Pct' in row and pd.notna(row['Variacion_Gastos_Directos_Pct']) else 0,
                'roi_porcentaje_anterior': float(row['ROI_Porcentaje_Anterior']) if 'ROI_Porcentaje_Anterior' in row and pd.notna(row['ROI_Porcentaje_Anterior']) else 0,
                'variacion_roi_pct': float(row['Variacion_ROI_Pct']) if 'Variacion_ROI_Pct' in row and pd.notna(row['Variacion_ROI_Pct']) else 0,
                'periodo_comparacion': str(row['Periodo_Comparacion']) if 'Periodo_Comparacion' in row and pd.notna(row['Periodo_Comparacion']) else 'Sin comparaciÃ³n',
                'dias_comparados': int(row['Dias_Comparados']) if 'Dias_Comparados' in row and pd.notna(row['Dias_Comparados']) else 0
            }
        else:
            # Canal sin datos en el perÃ­odo
            canal_data = {
                'canal': canal_nombre,
                'es_fila_principal': True,
                'es_subfila': False,
                'ventas_reales': 0,
                'costo_venta': 0,
                'gastos_directos': 0,
                'ingreso_real': 0,
                'costo_venta_porcentaje': 0,
                'gastos_directos_porcentaje': 0,
                'ingreso_real_porcentaje': 0,
                'roi_porcentaje': 0,
                'num_transacciones': 0,
                'ventas_reales_promedio': 0,
                'costo_venta_promedio': 0,
                'gastos_directos_promedio': 0,
                'ingreso_real_promedio': 0,
                'ingreso_real_porcentaje_anterior': 0,
                'variacion_ingreso_pct': 0,
                'variacion_ingreso_porcentaje_pct': 0,
                'ventas_reales_anterior': 0,
                'variacion_ventas_pct': 0,
                'costo_venta_anterior': 0,
                'costo_venta_porcentaje_anterior': 0,
                'variacion_costo_venta_pct': 0,
                'roi_porcentaje_anterior': 0,
                'variacion_roi_pct': 0,
                'periodo_comparacion': 'Sin datos',
                'dias_comparados': 0
            }
        
        canales_data.append(canal_data)
        
        # Generar subfilas por marca - IGUAL QUE EN CUMPLIMIENTO_METAS
        if not canal_row.empty:
            # Obtener datos del canal y marca anterior para las subfilas - CORREGIDO PARA INCLUIR TODAS LAS MÃ‰TRICAS
            canal_anterior_marca = {}
            if not ventas_por_canal_marca_anterior.empty:
                for _, fila_ant in ventas_por_canal_marca_anterior[ventas_por_canal_marca_anterior['Canal'] == canal_nombre].iterrows():
                    canal_anterior_marca[fila_ant['Marca']] = {
                        'ventas': fila_ant['Ventas_Reales'],
                        'ingreso_monto': fila_ant['Ingreso_Real'],  # Monto nominal del ingreso real
                        'ingreso_pct': fila_ant['Ingreso_Real_Porcentaje'],
                        'costo_pct': fila_ant['Costo_Venta_Porcentaje'],
                        'gastos_pct': fila_ant['Gastos_Directos_Porcentaje'],
                        'roi_pct': fila_ant['ROI_Porcentaje']
                    }
            
            # Buscar subfilas para este canal
            subfilas_marca = ventas_por_canal_marca[ventas_por_canal_marca['Canal'] == canal_nombre]
            
            # Sub-fila Loomber
            loomber_row = subfilas_marca[subfilas_marca['Marca'] == 'Loomber']
            if not loomber_row.empty:
                loomber = loomber_row.iloc[0]
                
                # Calcular variaciones para Loomber
                loomber_variacion_ingreso_nominal = 0  # VariaciÃ³n nominal del monto
                loomber_variacion_ingreso = 0  # VariaciÃ³n de puntos porcentuales
                loomber_variacion_ventas = 0
                loomber_variacion_costo = 0
                loomber_variacion_gastos = 0
                loomber_variacion_roi = 0
                loomber_ingreso_anterior = 0
                loomber_ingreso_monto_anterior = 0
                loomber_ventas_anterior = 0
                loomber_costo_anterior = 0
                loomber_gastos_anterior = 0
                loomber_roi_anterior = 0

                if 'Loomber' in canal_anterior_marca:
                    loomber_ingreso_anterior = canal_anterior_marca['Loomber']['ingreso_pct']
                    loomber_ingreso_monto_anterior = canal_anterior_marca['Loomber'].get('ingreso_monto', 0)
                    loomber_ventas_anterior = canal_anterior_marca['Loomber']['ventas']
                    loomber_costo_anterior = canal_anterior_marca['Loomber']['costo_pct']
                    loomber_gastos_anterior = canal_anterior_marca['Loomber']['gastos_pct']
                    loomber_roi_anterior = canal_anterior_marca['Loomber']['roi_pct']

                    # VariaciÃ³n de PUNTOS PORCENTUALES (para columna % Ingreso)
                    loomber_variacion_ingreso = loomber['Ingreso_Real_Porcentaje'] - loomber_ingreso_anterior

                    # VariaciÃ³n NOMINAL del monto (para columna Ingreso Real)
                    if loomber_ingreso_monto_anterior != 0:
                        loomber_variacion_ingreso_nominal = ((loomber['Ingreso_Real'] - loomber_ingreso_monto_anterior) /
                                                             abs(loomber_ingreso_monto_anterior) * 100)

                    loomber_variacion_roi = loomber['ROI_Porcentaje'] - loomber_roi_anterior
                    if loomber_ventas_anterior > 0:
                        loomber_variacion_ventas = ((loomber['Ventas_Reales'] - loomber_ventas_anterior) / loomber_ventas_anterior * 100)
                
                # Calcular representaciÃ³n dentro del canal
                ventas_canal_total = float(canal_row.iloc[0]['Ventas_Reales']) if not canal_row.empty else 0
                representacion_loomber = (float(loomber['Ventas_Reales']) / ventas_canal_total * 100) if ventas_canal_total > 0 else 0

                # Calcular porcentajes de costo y gastos para Loomber
                loomber_costo_pct = (float(loomber['Costo_Venta']) / float(loomber['Ventas_Reales']) * 100) if float(loomber['Ventas_Reales']) > 0 else 0
                loomber_gastos_pct = (float(loomber['Gastos_Directos']) / float(loomber['Ventas_Reales']) * 100) if float(loomber['Ventas_Reales']) > 0 else 0

                # Calcular variaciones de costo y gastos para Loomber
                loomber_variacion_costo = loomber_costo_pct - loomber_costo_anterior
                loomber_variacion_gastos = loomber_gastos_pct - loomber_gastos_anterior
                
                loomber_data = {
                    'canal': f"{canal_nombre} - Loomber",
                    'es_fila_principal': False,
                    'es_subfila': True,
                    'canal_padre': canal_nombre,
                    'marca_tipo': 'Loomber',
                    'ventas_reales': float(loomber['Ventas_Reales']),
                    'costo_venta': float(loomber['Costo_Venta']),
                    'gastos_directos': float(loomber['Gastos_Directos']),
                    'ingreso_real': float(loomber['Ingreso_Real']),
                    'costo_venta_porcentaje': float(loomber_costo_pct),
                    'gastos_directos_porcentaje': float(loomber_gastos_pct),
                    'ingreso_real_porcentaje': float(loomber['Ingreso_Real_Porcentaje']),
                    'roi_porcentaje': float(loomber['ROI_Porcentaje']),
                    'num_transacciones': int(loomber['Num_Transacciones']),
                    'representacion_ventas': representacion_loomber,
                    # CAMPOS DE COMPARACIÃ“N CON MES ANTERIOR
                    'ingreso_real_porcentaje_anterior': float(loomber_ingreso_anterior),
                    'variacion_ingreso_pct': float(loomber_variacion_ingreso_nominal),  # VariaciÃ³n nominal del monto
                    'variacion_ingreso_porcentaje_pct': float(loomber_variacion_ingreso),  # VariaciÃ³n pp del %
                    'ventas_reales_anterior': float(loomber_ventas_anterior),
                    'variacion_ventas_pct': float(loomber_variacion_ventas),
                    'costo_venta_porcentaje_anterior': float(loomber_costo_anterior),
                    'variacion_costo_venta_pct': float(loomber_variacion_costo),
                    'gastos_directos_porcentaje_anterior': float(loomber_gastos_anterior),
                    'variacion_gastos_directos_pct': float(loomber_variacion_gastos),
                    'roi_porcentaje_anterior': float(loomber_roi_anterior),
                    'variacion_roi_pct': float(loomber_variacion_roi),
                    'periodo_comparacion': str(canal_row.iloc[0]['Periodo_Comparacion']) if 'Periodo_Comparacion' in canal_row.iloc[0] else 'Sin comparaciÃ³n',
                    'dias_comparados': int(canal_row.iloc[0]['Dias_Comparados']) if 'Dias_Comparados' in canal_row.iloc[0] and pd.notna(canal_row.iloc[0]['Dias_Comparados']) else 0
                }
                canales_data.append(loomber_data)
            
            # Sub-fila Otros
            otros_rows = subfilas_marca[subfilas_marca['Marca'] == 'Otros']
            if not otros_rows.empty:
                # Datos de la marca "Otros" (ya viene agregada desde la tabla base)
                otros_totals = otros_rows.agg({
                    'Ventas_Reales': 'sum',
                    'Costo_Venta': 'sum',
                    'Gastos_Directos': 'sum',
                    'Ingreso_Real': 'sum',
                    'Num_Transacciones': 'sum'
                })
                
                otros_ingreso_pct = (otros_totals['Ingreso_Real'] / otros_totals['Ventas_Reales'] * 100) if otros_totals['Ventas_Reales'] > 0 else 0

                # Calcular porcentajes de costo y gastos para Otros PRIMERO
                otros_costo_pct = (float(otros_totals['Costo_Venta']) / float(otros_totals['Ventas_Reales']) * 100) if float(otros_totals['Ventas_Reales']) > 0 else 0
                otros_gastos_pct = (float(otros_totals['Gastos_Directos']) / float(otros_totals['Ventas_Reales']) * 100) if float(otros_totals['Ventas_Reales']) > 0 else 0

                # âœ… NUEVO: Calcular ROI para Otros usando datos agregados
                otros_roi_pct = (float(otros_totals['Ingreso_Real']) / float(otros_totals['Costo_Venta']) * 100) if float(otros_totals['Costo_Venta']) > 0 else 0

                # Calcular variaciones para Otros
                otros_variacion_ingreso_nominal = 0  # VariaciÃ³n nominal del monto
                otros_variacion_ingreso = 0  # VariaciÃ³n de puntos porcentuales
                otros_variacion_ventas = 0
                otros_variacion_costo = 0
                otros_variacion_gastos = 0
                otros_variacion_roi = 0
                otros_ingreso_anterior = 0
                otros_ingreso_monto_anterior = 0
                otros_ventas_anterior = 0
                otros_costo_anterior = 0
                otros_gastos_anterior = 0
                otros_roi_anterior = 0

                # Buscar datos de la marca "Otros" del mes anterior
                otros_anterior = ventas_por_canal_marca_anterior[
                    (ventas_por_canal_marca_anterior['Canal'] == canal_nombre) &
                    (ventas_por_canal_marca_anterior['Marca'] == 'Otros')
                ]

                if not otros_anterior.empty:
                    otros_anterior_totals = otros_anterior.agg({
                        'Ventas_Reales': 'sum',
                        'Costo_Venta': 'sum',
                        'Gastos_Directos': 'sum',
                        'Ingreso_Real': 'sum'
                    })
                    otros_ventas_anterior = otros_anterior_totals['Ventas_Reales']
                    otros_ingreso_monto_anterior = otros_anterior_totals['Ingreso_Real']
                    otros_ingreso_anterior = (otros_ingreso_monto_anterior / otros_ventas_anterior * 100) if otros_ventas_anterior > 0 else 0
                    otros_costo_anterior = (otros_anterior_totals['Costo_Venta'] / otros_ventas_anterior * 100) if otros_ventas_anterior > 0 else 0
                    otros_gastos_anterior = (otros_anterior_totals['Gastos_Directos'] / otros_ventas_anterior * 100) if otros_ventas_anterior > 0 else 0
                    otros_roi_anterior = (otros_ingreso_monto_anterior / otros_anterior_totals['Costo_Venta'] * 100) if otros_anterior_totals['Costo_Venta'] > 0 else 0

                    # VariaciÃ³n de PUNTOS PORCENTUALES (para columna % Ingreso)
                    otros_variacion_ingreso = otros_ingreso_pct - otros_ingreso_anterior

                    # VariaciÃ³n NOMINAL del monto (para columna Ingreso Real)
                    if otros_ingreso_monto_anterior != 0:
                        otros_variacion_ingreso_nominal = ((otros_totals['Ingreso_Real'] - otros_ingreso_monto_anterior) /
                                                           abs(otros_ingreso_monto_anterior) * 100)
                    otros_variacion_costo = otros_costo_pct - otros_costo_anterior
                    otros_variacion_gastos = otros_gastos_pct - otros_gastos_anterior
                    otros_variacion_roi = otros_roi_pct - otros_roi_anterior
                    if otros_ventas_anterior > 0:
                        otros_variacion_ventas = ((otros_totals['Ventas_Reales'] - otros_ventas_anterior) / otros_ventas_anterior * 100)

                # Calcular representaciÃ³n dentro del canal para Otros
                representacion_otros = (float(otros_totals['Ventas_Reales']) / ventas_canal_total * 100) if ventas_canal_total > 0 else 0
                
                otros_data = {
                    'canal': f"{canal_nombre} - Otros",
                    'es_fila_principal': False,
                    'es_subfila': True,
                    'canal_padre': canal_nombre,
                    'marca_tipo': 'Otros',
                    'ventas_reales': float(otros_totals['Ventas_Reales']),
                    'costo_venta': float(otros_totals['Costo_Venta']),
                    'gastos_directos': float(otros_totals['Gastos_Directos']),
                    'ingreso_real': float(otros_totals['Ingreso_Real']),
                    'costo_venta_porcentaje': float(otros_costo_pct),
                    'gastos_directos_porcentaje': float(otros_gastos_pct),
                    'ingreso_real_porcentaje': float(otros_ingreso_pct),
                    'roi_porcentaje': float(otros_roi_pct),
                    'num_transacciones': int(otros_totals['Num_Transacciones']),
                    'representacion_ventas': representacion_otros,
                    # CAMPOS DE COMPARACIÃ“N CON MES ANTERIOR
                    'ingreso_real_porcentaje_anterior': float(otros_ingreso_anterior),
                    'variacion_ingreso_pct': float(otros_variacion_ingreso_nominal),  # VariaciÃ³n nominal del monto
                    'variacion_ingreso_porcentaje_pct': float(otros_variacion_ingreso),  # VariaciÃ³n pp del %
                    'ventas_reales_anterior': float(otros_ventas_anterior),
                    'variacion_ventas_pct': float(otros_variacion_ventas),
                    'costo_venta_porcentaje_anterior': float(otros_costo_anterior),
                    'variacion_costo_venta_pct': float(otros_variacion_costo),
                    'gastos_directos_porcentaje_anterior': float(otros_gastos_anterior),
                    'variacion_gastos_directos_pct': float(otros_variacion_gastos),
                    'roi_porcentaje_anterior': float(otros_roi_anterior),
                    'variacion_roi_pct': float(otros_variacion_roi),
                    'periodo_comparacion': str(canal_row.iloc[0]['Periodo_Comparacion']) if 'Periodo_Comparacion' in canal_row.iloc[0] else 'Sin comparaciÃ³n',
                    'dias_comparados': int(canal_row.iloc[0]['Dias_Comparados']) if 'Dias_Comparados' in canal_row.iloc[0] and pd.notna(canal_row.iloc[0]['Dias_Comparados']) else 0
                }
                canales_data.append(otros_data)

                # NUEVO: Generar sub-subfilas de categorÃ­as para Loomber
                if not loomber_row.empty:
                    loomber_categorias = ventas_por_canal_marca_categoria[
                        (ventas_por_canal_marca_categoria['Canal'] == canal_nombre) &
                        (ventas_por_canal_marca_categoria['Marca'] == 'Loomber')
                    ].nlargest(3, 'Ventas_Reales')  # Top 3 categorÃ­as de Loomber

                    for _, categoria_row in loomber_categorias.iterrows():
                        # NUEVO: Calcular variaciÃ³n con mes anterior para esta categorÃ­a especÃ­fica
                        categoria_variacion_ventas = 0.0
                        categoria_variacion_ingreso = 0.0  # VariaciÃ³n en puntos porcentuales
                        categoria_variacion_ingreso_nominal = 0.0  # VariaciÃ³n nominal del monto
                        categoria_variacion_costo = 0.0
                        categoria_variacion_gastos = 0.0
                        categoria_variacion_roi = 0.0
                        categoria_ventas_anterior = 0
                        categoria_ingreso_anterior = 0  # Porcentaje anterior
                        categoria_ingreso_monto_anterior = 0  # Monto anterior
                        categoria_roi_anterior = 0.0
                        categoria_costo_anterior = 0
                        categoria_gastos_anterior = 0

                        # Buscar datos exactos de esta categorÃ­a en el mes anterior
                        if not ventas_por_canal_marca_categoria_anterior.empty:
                            try:
                                # Buscar datos exactos de esta categorÃ­a especÃ­fica del mes anterior
                                categoria_anterior_data = ventas_por_canal_marca_categoria_anterior[
                                    (ventas_por_canal_marca_categoria_anterior['Canal'] == canal_nombre) &
                                    (ventas_por_canal_marca_categoria_anterior['Marca'] == 'Loomber') &
                                    (ventas_por_canal_marca_categoria_anterior['Categoria'] == categoria_row['Categoria'])
                                ]

                                if not categoria_anterior_data.empty:
                                    # USAR DATOS EXACTOS (no aproximaciones)
                                    categoria_anterior = categoria_anterior_data.iloc[0]
                                    categoria_ventas_anterior = float(categoria_anterior['Ventas_Reales'])
                                    categoria_ingreso_anterior = float(categoria_anterior['Ingreso_Real_Porcentaje'])
                                    categoria_ingreso_monto_anterior = float(categoria_anterior['Ingreso_Real'])
                                    categoria_costo_anterior = float(categoria_anterior['Costo_Venta_Porcentaje'])
                                    categoria_gastos_anterior = float(categoria_anterior['Gastos_Directos_Porcentaje'])

                                    # Calcular variaciones con datos exactos
                                    if categoria_ventas_anterior > 0:
                                        categoria_variacion_ventas = ((float(categoria_row['Ventas_Reales']) - categoria_ventas_anterior) / categoria_ventas_anterior * 100)

                                    # Calcular variaciÃ³n en PUNTOS PORCENTUALES (para columna % Ingreso)
                                    categoria_variacion_ingreso = float(categoria_row['Ingreso_Real_Porcentaje']) - categoria_ingreso_anterior

                                    # Calcular variaciÃ³n NOMINAL del monto (para columna Ingreso Real)
                                    if categoria_ingreso_monto_anterior != 0:
                                        categoria_variacion_ingreso_nominal = ((float(categoria_row['Ingreso_Real']) - categoria_ingreso_monto_anterior) /
                                                                               abs(categoria_ingreso_monto_anterior) * 100)

                                    categoria_variacion_costo = float(categoria_row['Costo_Venta_Porcentaje']) - categoria_costo_anterior
                                    categoria_variacion_gastos = float(categoria_row['Gastos_Directos_Porcentaje']) - categoria_gastos_anterior
                                    # âœ… NUEVO: Calcular variaciÃ³n de ROI para categorÃ­as
                                    categoria_costo_anterior_valor = float(categoria_anterior['Costo_Venta'])
                                    categoria_ingreso_anterior_valor = float(categoria_anterior['Ingreso_Real'])
                                    categoria_roi_anterior = (categoria_ingreso_anterior_valor / categoria_costo_anterior_valor * 100) if categoria_costo_anterior_valor > 0 else 0.0
                                    categoria_variacion_roi = float(categoria_row['ROI_Porcentaje']) - categoria_roi_anterior

                                    # print(f"âœ… LOOMBER {categoria_row['Categoria']}: Ventas ${categoria_ventas_anterior:,.0f} â†’ ${categoria_row['Ventas_Reales']:,.0f} ({categoria_variacion_ventas:+.1f}%)")
                                    # print(f"ðŸ” DEBUG ROI CATEGORIA LOOMBER {categoria_row['Categoria']}: ROI_Actual={categoria_row['ROI_Porcentaje']:.2f}%, ROI_Anterior={categoria_roi_anterior:.2f}%, Variacion={categoria_variacion_roi:+.2f}pp")
                                else:
                                    print(f"âš ï¸ LOOMBER {categoria_row['Categoria']}: Sin datos del mes anterior para comparaciÃ³n exacta")
                                    # âœ… NUEVO: Asegurar que las variables estÃ©n inicializadas cuando no hay datos anteriores
                                    categoria_roi_anterior = 0.0
                                    categoria_variacion_roi = float(categoria_row['ROI_Porcentaje']) - categoria_roi_anterior
                                    # print(f"ðŸ” DEBUG ROI CATEGORIA LOOMBER {categoria_row['Categoria']} (SIN DATOS ANTERIORES): ROI_Actual={categoria_row['ROI_Porcentaje']:.2f}%, ROI_Anterior={categoria_roi_anterior:.2f}%, Variacion={categoria_variacion_roi:+.2f}pp")

                            except Exception as e:
                                print(f"Error calculando variaciÃ³n exacta para categorÃ­a Loomber {categoria_row['Categoria']}: {e}")

                        categoria_data = {
                            'canal': f"{canal_nombre} - Loomber - {categoria_row['Categoria']}",
                            'ventas_reales': float(categoria_row['Ventas_Reales']),
                            'costo_venta': float(categoria_row['Costo_Venta']),
                            'gastos_directos': float(categoria_row['Gastos_Directos']),
                            'ingreso_real': float(categoria_row['Ingreso_Real']),
                            'ventas_reales_promedio': float(categoria_row['Ventas_Reales_Promedio']),
                            'costo_venta_promedio': float(categoria_row['Costo_Venta_Promedio']),
                            'gastos_directos_promedio': float(categoria_row['Gastos_Directos_Promedio']),
                            'ingreso_real_promedio': float(categoria_row['Ingreso_Real_Promedio']),
                            'costo_venta_porcentaje': float(categoria_row['Costo_Venta_Porcentaje']),
                            'gastos_directos_porcentaje': float(categoria_row['Gastos_Directos_Porcentaje']),
                            'ingreso_real_porcentaje': float(categoria_row['Ingreso_Real_Porcentaje']),
                            'roi_porcentaje': float(categoria_row['ROI_Porcentaje']),
                            'num_transacciones': int(categoria_row['Num_Transacciones']),
                            'es_fila_principal': False,
                            'es_subfila': False,
                            'es_categoria_row': True,
                            'marca_tipo': 'Loomber',
                            'categoria_nombre': categoria_row['Categoria'],
                            'representacion_ventas': (float(categoria_row['Ventas_Reales']) / float(loomber_row.iloc[0]['Ventas_Reales']) * 100) if float(loomber_row.iloc[0]['Ventas_Reales']) > 0 else 0,
                            'variacion_ingreso_pct': float(categoria_variacion_ingreso_nominal),  # VariaciÃ³n nominal del monto
                            'variacion_ingreso_porcentaje_pct': float(categoria_variacion_ingreso),  # VariaciÃ³n pp del %
                            'variacion_ventas_pct': float(categoria_variacion_ventas),
                            'variacion_costo_venta_pct': float(categoria_variacion_costo),
                            'variacion_gastos_directos_pct': float(categoria_variacion_gastos),
                            'variacion_roi_pct': float(categoria_variacion_roi),
                            'ingreso_real_porcentaje_anterior': float(categoria_ingreso_anterior),
                            'ventas_reales_anterior': float(categoria_ventas_anterior),
                            'costo_venta_porcentaje_anterior': float(categoria_costo_anterior),
                            'gastos_directos_porcentaje_anterior': float(categoria_gastos_anterior),
                            'roi_porcentaje_anterior': float(categoria_roi_anterior),
                            'periodo_comparacion': str(canal_row.iloc[0]['Periodo_Comparacion']) if 'Periodo_Comparacion' in canal_row.iloc[0] else 'Sin comparaciÃ³n',
                            'dias_comparados': int(canal_row.iloc[0]['Dias_Comparados']) if 'Dias_Comparados' in canal_row.iloc[0] and pd.notna(canal_row.iloc[0]['Dias_Comparados']) else 0
                        }
                        # print(f"ðŸ” DEBUG FINAL CATEGORIA LOOMBER {categoria_row['Categoria']}: variacion_roi_pct={categoria_data['variacion_roi_pct']:.2f}")
                        canales_data.append(categoria_data)

                # NUEVO: Generar sub-subfilas de categorÃ­as para Otros
                if not otros_rows.empty:
                    otros_categorias = ventas_por_canal_marca_categoria[
                        (ventas_por_canal_marca_categoria['Canal'] == canal_nombre) &
                        (ventas_por_canal_marca_categoria['Marca'] == 'Otros')
                    ].nlargest(3, 'Ventas_Reales')  # Top 3 categorÃ­as de Otros

                    for _, categoria_row in otros_categorias.iterrows():
                        # NUEVO: Calcular variaciÃ³n con mes anterior para esta categorÃ­a especÃ­fica (Otros)
                        categoria_variacion_ventas = 0.0
                        categoria_variacion_ingreso = 0.0  # VariaciÃ³n en puntos porcentuales
                        categoria_variacion_ingreso_nominal = 0.0  # VariaciÃ³n nominal del monto
                        categoria_variacion_costo = 0.0
                        categoria_variacion_gastos = 0.0
                        categoria_variacion_roi = 0.0
                        categoria_ventas_anterior = 0
                        categoria_roi_anterior = 0.0
                        categoria_ingreso_anterior = 0  # Porcentaje anterior
                        categoria_ingreso_monto_anterior = 0  # Monto anterior
                        categoria_costo_anterior = 0
                        categoria_gastos_anterior = 0

                        # Buscar datos exactos de esta categorÃ­a en el mes anterior (para marcas Otros)
                        if not ventas_por_canal_marca_categoria_anterior.empty:
                            try:
                                # Buscar datos exactos de esta categorÃ­a especÃ­fica para la marca "Otros" del mes anterior
                                categoria_anterior_data = ventas_por_canal_marca_categoria_anterior[
                                    (ventas_por_canal_marca_categoria_anterior['Canal'] == canal_nombre) &
                                    (ventas_por_canal_marca_categoria_anterior['Marca'] == 'Otros') &
                                    (ventas_por_canal_marca_categoria_anterior['Categoria'] == categoria_row['Categoria'])
                                ]

                                if not categoria_anterior_data.empty:
                                    # USAR DATOS EXACTOS (datos de la marca "Otros" de esta categorÃ­a)
                                    categoria_anterior_totals = categoria_anterior_data.agg({
                                        'Ventas_Reales': 'sum',
                                        'Costo_Venta': 'sum',
                                        'Gastos_Directos': 'sum',
                                        'Ingreso_Real': 'sum'
                                    })

                                    categoria_ventas_anterior = float(categoria_anterior_totals['Ventas_Reales'])
                                    categoria_ingreso_monto_anterior = float(categoria_anterior_totals['Ingreso_Real'])
                                    categoria_ingreso_anterior = (categoria_ingreso_monto_anterior / categoria_ventas_anterior * 100) if categoria_ventas_anterior > 0 else 0
                                    categoria_costo_anterior = (float(categoria_anterior_totals['Costo_Venta']) / categoria_ventas_anterior * 100) if categoria_ventas_anterior > 0 else 0
                                    categoria_gastos_anterior = (float(categoria_anterior_totals['Gastos_Directos']) / categoria_ventas_anterior * 100) if categoria_ventas_anterior > 0 else 0

                                    # Calcular variaciones con datos exactos
                                    if categoria_ventas_anterior > 0:
                                        categoria_variacion_ventas = ((float(categoria_row['Ventas_Reales']) - categoria_ventas_anterior) / categoria_ventas_anterior * 100)

                                    # Calcular variaciÃ³n en PUNTOS PORCENTUALES (para columna % Ingreso)
                                    categoria_variacion_ingreso = float(categoria_row['Ingreso_Real_Porcentaje']) - categoria_ingreso_anterior

                                    # Calcular variaciÃ³n NOMINAL del monto (para columna Ingreso Real)
                                    if categoria_ingreso_monto_anterior != 0:
                                        categoria_variacion_ingreso_nominal = ((float(categoria_row['Ingreso_Real']) - categoria_ingreso_monto_anterior) /
                                                                               abs(categoria_ingreso_monto_anterior) * 100)

                                    categoria_variacion_costo = float(categoria_row['Costo_Venta_Porcentaje']) - categoria_costo_anterior
                                    categoria_variacion_gastos = float(categoria_row['Gastos_Directos_Porcentaje']) - categoria_gastos_anterior
                                    # âœ… NUEVO: Calcular variaciÃ³n de ROI para categorÃ­as (Otros)
                                    categoria_costo_anterior_valor = float(categoria_anterior_totals['Costo_Venta'])
                                    categoria_ingreso_anterior_valor = float(categoria_anterior_totals['Ingreso_Real'])
                                    categoria_roi_anterior = (categoria_ingreso_anterior_valor / categoria_costo_anterior_valor * 100) if categoria_costo_anterior_valor > 0 else 0.0
                                    categoria_variacion_roi = float(categoria_row['ROI_Porcentaje']) - categoria_roi_anterior

                                    # print(f"âœ… OTROS {categoria_row['Categoria']}: Ventas ${categoria_ventas_anterior:,.0f} â†’ ${categoria_row['Ventas_Reales']:,.0f} ({categoria_variacion_ventas:+.1f}%)")
                                    # print(f"ðŸ” DEBUG ROI CATEGORIA OTROS {categoria_row['Categoria']}: ROI_Actual={categoria_row['ROI_Porcentaje']:.2f}%, ROI_Anterior={categoria_roi_anterior:.2f}%, Variacion={categoria_variacion_roi:+.2f}pp")
                                else:
                                    print(f"âš ï¸ OTROS {categoria_row['Categoria']}: Sin datos del mes anterior para comparaciÃ³n exacta")
                                    # âœ… NUEVO: Asegurar que las variables estÃ©n inicializadas cuando no hay datos anteriores
                                    categoria_roi_anterior = 0.0
                                    categoria_variacion_roi = float(categoria_row['ROI_Porcentaje']) - categoria_roi_anterior
                                    # print(f"ðŸ” DEBUG ROI CATEGORIA OTROS {categoria_row['Categoria']} (SIN DATOS ANTERIORES): ROI_Actual={categoria_row['ROI_Porcentaje']:.2f}%, ROI_Anterior={categoria_roi_anterior:.2f}%, Variacion={categoria_variacion_roi:+.2f}pp")

                            except Exception as e:
                                print(f"Error calculando variaciÃ³n exacta para categorÃ­a Otros {categoria_row['Categoria']}: {e}")

                        categoria_data = {
                            'canal': f"{canal_nombre} - Otros - {categoria_row['Categoria']}",
                            'ventas_reales': float(categoria_row['Ventas_Reales']),
                            'costo_venta': float(categoria_row['Costo_Venta']),
                            'gastos_directos': float(categoria_row['Gastos_Directos']),
                            'ingreso_real': float(categoria_row['Ingreso_Real']),
                            'ventas_reales_promedio': float(categoria_row['Ventas_Reales_Promedio']),
                            'costo_venta_promedio': float(categoria_row['Costo_Venta_Promedio']),
                            'gastos_directos_promedio': float(categoria_row['Gastos_Directos_Promedio']),
                            'ingreso_real_promedio': float(categoria_row['Ingreso_Real_Promedio']),
                            'costo_venta_porcentaje': float(categoria_row['Costo_Venta_Porcentaje']),
                            'gastos_directos_porcentaje': float(categoria_row['Gastos_Directos_Porcentaje']),
                            'ingreso_real_porcentaje': float(categoria_row['Ingreso_Real_Porcentaje']),
                            'roi_porcentaje': float(categoria_row['ROI_Porcentaje']),
                            'num_transacciones': int(categoria_row['Num_Transacciones']),
                            'es_fila_principal': False,
                            'es_subfila': False,
                            'es_categoria_row': True,
                            'marca_tipo': 'Otros',
                            'categoria_nombre': categoria_row['Categoria'],
                            'representacion_ventas': (float(categoria_row['Ventas_Reales']) / float(otros_totals['Ventas_Reales']) * 100) if float(otros_totals['Ventas_Reales']) > 0 else 0,
                            'variacion_ingreso_pct': float(categoria_variacion_ingreso_nominal),  # VariaciÃ³n nominal del monto
                            'variacion_ingreso_porcentaje_pct': float(categoria_variacion_ingreso),  # VariaciÃ³n pp del %
                            'variacion_ventas_pct': float(categoria_variacion_ventas),
                            'variacion_costo_venta_pct': float(categoria_variacion_costo),
                            'variacion_gastos_directos_pct': float(categoria_variacion_gastos),
                            'variacion_roi_pct': float(categoria_variacion_roi),
                            'ingreso_real_porcentaje_anterior': float(categoria_ingreso_anterior),
                            'ventas_reales_anterior': float(categoria_ventas_anterior),
                            'costo_venta_porcentaje_anterior': float(categoria_costo_anterior),
                            'gastos_directos_porcentaje_anterior': float(categoria_gastos_anterior),
                            'roi_porcentaje_anterior': float(categoria_roi_anterior),
                            'periodo_comparacion': str(canal_row.iloc[0]['Periodo_Comparacion']) if 'Periodo_Comparacion' in canal_row.iloc[0] else 'Sin comparaciÃ³n',
                            'dias_comparados': int(canal_row.iloc[0]['Dias_Comparados']) if 'Dias_Comparados' in canal_row.iloc[0] and pd.notna(canal_row.iloc[0]['Dias_Comparados']) else 0
                        }
                        # print(f"ðŸ” DEBUG FINAL CATEGORIA OTROS {categoria_row['Categoria']}: variacion_roi_pct={categoria_data['variacion_roi_pct']:.2f}")
                        canales_data.append(categoria_data)

    print(f"INFO: Generados datos para {len([c for c in canales_data if c['es_fila_principal']])} canales principales")
    print(f"INFO: Generadas {len([c for c in canales_data if c['es_subfila']])} sub-filas de marca")
    print(f"INFO: Generadas {len([c for c in canales_data if c.get('es_categoria_row', False)])} sub-subfilas de categorÃ­a")
    
    # RESUMEN FINAL DE VARIACIONES
    canales_con_variacion = len([c for c in canales_data if c['es_fila_principal'] and c['variacion_ingreso_pct'] != 0])
    print(f"=== RESUMEN DE VARIACIONES CALCULADAS ===")
    print(f"âœ“ Canales con datos de comparaciÃ³n: {canales_con_variacion}/{len([c for c in canales_data if c['es_fila_principal']])}")

    tiempo_funcion_fin = time.time()
    print(f"ðŸ” [PERFORMANCE] FIN - generar_datos_canales_principales(): {tiempo_funcion_fin - tiempo_funcion_inicio:.3f} segundos")
    sys.stdout.flush()

    return canales_data

def unificar_productos_por_categoria_dominante(skus_estrella, skus_prometedores, skus_potenciales, skus_revision=None, skus_remover=None):
    """
    Unifica productos considerando SKUs componentes de todas las categorÃ­as.
    Determina la categorÃ­a donde mostrar cada producto unificado basÃ¡ndose en el SKU con mayores ventas.

    Args:
        skus_estrella: Lista de SKUs Estrella
        skus_prometedores: Lista de SKUs Prometedores
        skus_potenciales: Lista de SKUs Potenciales
        skus_revision: Lista de SKUs RevisiÃ³n (opcional)
        skus_remover: Lista de SKUs Remover (opcional)

    Returns:
        Tupla con las 5 listas actualizadas (estrella, prometedores, potenciales, revision, remover)
    """
    print(f"ðŸ”„ Iniciando unificaciÃ³n global de productos...")

    # Manejar parÃ¡metros opcionales
    if skus_revision is None:
        skus_revision = []
    if skus_remover is None:
        skus_remover = []

    print(f"ðŸ“Š Input: {len(skus_estrella)} Estrella, {len(skus_prometedores)} Prometedores, {len(skus_potenciales)} Potenciales, {len(skus_revision)} RevisiÃ³n, {len(skus_remover)} Remover")

    # Crear diccionario global con todos los SKUs de todas las categorÃ­as
    todos_los_skus = {}

    # AÃ±adir SKUs de cada categorÃ­a con su categorÃ­a original
    for sku_data in skus_estrella:
        if not sku_data.get('es_fila_total', False):
            sku_data['categoria_original'] = 'estrella'
            todos_los_skus[sku_data['sku']] = sku_data

    for sku_data in skus_prometedores:
        if not sku_data.get('es_fila_total', False):
            sku_data['categoria_original'] = 'prometedores'
            todos_los_skus[sku_data['sku']] = sku_data

    for sku_data in skus_potenciales:
        if not sku_data.get('es_fila_total', False):
            sku_data['categoria_original'] = 'potenciales'
            todos_los_skus[sku_data['sku']] = sku_data

    for sku_data in skus_revision:
        if not sku_data.get('es_fila_total', False):
            sku_data['categoria_original'] = 'revision'
            todos_los_skus[sku_data['sku']] = sku_data

    for sku_data in skus_remover:
        if not sku_data.get('es_fila_total', False):
            sku_data['categoria_original'] = 'remover'
            todos_los_skus[sku_data['sku']] = sku_data

    print(f"ðŸ“¦ Total SKUs encontrados: {len(todos_los_skus)}")

    # Crear diccionario inverso para mapeo rÃ¡pido: sku_gemelo -> sku_principal
    mapeo_inverso = {}
    for sku_principal, gemelos in PRODUCTOS_UNIFICADOS.items():
        mapeo_inverso[sku_principal] = sku_principal
        for gemelo in gemelos:
            mapeo_inverso[gemelo] = sku_principal

    # Determinar categorÃ­a dominante para cada producto unificado
    productos_unificados_info = {}

    for sku_principal, gemelos in PRODUCTOS_UNIFICADOS.items():
        # Buscar todos los componentes de este producto unificado
        componentes_encontrados = []
        todos_componentes = [sku_principal] + gemelos

        for componente in todos_componentes:
            if componente in todos_los_skus:
                componentes_encontrados.append(todos_los_skus[componente])

        if componentes_encontrados:
            # Determinar el componente con mayores ventas
            componente_dominante = max(componentes_encontrados, key=lambda x: x['ventas_reales'])
            categoria_dominante = componente_dominante['categoria_original']

            productos_unificados_info[sku_principal] = {
                'categoria_dominante': categoria_dominante,
                'componentes': componentes_encontrados,
                'sku_dominante': componente_dominante['sku'],
                'ventas_dominantes': componente_dominante['ventas_reales']
            }

            print(f"ðŸŽ¯ {sku_principal}: {len(componentes_encontrados)} componentes â†’ CategorÃ­a: {categoria_dominante} (${componente_dominante['ventas_reales']:,.0f})")

    # Separar filas de totales por categorÃ­a
    totales_estrella = [s for s in skus_estrella if s.get('es_fila_total', False)]
    totales_prometedores = [s for s in skus_prometedores if s.get('es_fila_total', False)]
    totales_potenciales = [s for s in skus_potenciales if s.get('es_fila_total', False)]
    totales_revision = [s for s in skus_revision if s.get('es_fila_total', False)]
    totales_remover = [s for s in skus_remover if s.get('es_fila_total', False)]

    # Aplicar unificaciÃ³n a cada categorÃ­a
    skus_estrella_unificados = unificar_skus_para_categoria(
        'estrella', productos_unificados_info, todos_los_skus, totales_estrella
    )

    skus_prometedores_unificados = unificar_skus_para_categoria(
        'prometedores', productos_unificados_info, todos_los_skus, totales_prometedores
    )

    skus_potenciales_unificados = unificar_skus_para_categoria(
        'potenciales', productos_unificados_info, todos_los_skus, totales_potenciales
    )

    skus_revision_unificados = unificar_skus_para_categoria(
        'revision', productos_unificados_info, todos_los_skus, totales_revision
    )

    skus_remover_unificados = unificar_skus_para_categoria(
        'remover', productos_unificados_info, todos_los_skus, totales_remover
    )

    print(f"âœ… Output: {len(skus_estrella_unificados)} Estrella, {len(skus_prometedores_unificados)} Prometedores, {len(skus_potenciales_unificados)} Potenciales, {len(skus_revision_unificados)} RevisiÃ³n, {len(skus_remover_unificados)} Remover")

    # DEBUG: Verificar posiciÃ³n de fila de totales en Prometedores
    if skus_prometedores_unificados:
        primer_item = skus_prometedores_unificados[0]
        ultimo_item = skus_prometedores_unificados[-1]
        print(f"ðŸ” DEBUG PROMETEDORES - Primer item: es_fila_total={primer_item.get('es_fila_total', False)}, producto={primer_item.get('producto', primer_item.get('sku', 'N/A'))[:30]}")
        print(f"ðŸ” DEBUG PROMETEDORES - Ãšltimo item: es_fila_total={ultimo_item.get('es_fila_total', False)}, producto={ultimo_item.get('producto', ultimo_item.get('sku', 'N/A'))[:30]}")

    return skus_estrella_unificados, skus_prometedores_unificados, skus_potenciales_unificados, skus_revision_unificados, skus_remover_unificados


def unificar_skus_para_categoria(categoria_objetivo, productos_unificados_info, todos_los_skus, filas_totales):
    """
    Unifica SKUs para una categorÃ­a especÃ­fica basÃ¡ndose en la informaciÃ³n de productos unificados.
    """
    print(f"ðŸ”§ Procesando categorÃ­a: {categoria_objetivo}")

    resultado_final = []
    skus_ya_procesados = set()

    # Crear diccionario inverso para saber quÃ© SKUs pertenecen a productos unificados
    mapeo_inverso = {}
    for sku_principal, gemelos in PRODUCTOS_UNIFICADOS.items():
        mapeo_inverso[sku_principal] = sku_principal
        for gemelo in gemelos:
            mapeo_inverso[gemelo] = sku_principal

    # 1. Procesar productos unificados que pertenecen a esta categorÃ­a
    productos_unificados_de_categoria = []
    skus_no_unificados = []  # Inicializar aquÃ­

    for sku_principal, info in productos_unificados_info.items():
        if info['categoria_dominante'] == categoria_objetivo:
            print(f"   ðŸ“¦ Procesando producto unificado: {sku_principal} con {len(info['componentes'])} componentes")

            # Crear producto unificado (o SKU individual si solo hay 1 con ventas)
            producto_unificado = crear_producto_unificado(sku_principal, info['componentes'])
            if producto_unificado:
                # Verificar si se unificÃ³ o si es un SKU individual
                if producto_unificado.get('es_producto_unificado', False):
                    # Es un producto unificado (2+ componentes con ventas)
                    productos_unificados_de_categoria.append({
                        'producto_unificado': producto_unificado,
                        'componentes': info['componentes'],
                        'sku_principal': sku_principal
                    })
                    # Marcar TODOS los componentes como procesados
                    for componente in info['componentes']:
                        skus_ya_procesados.add(componente['sku'])
                        print(f"      âœ“ Componente procesado: {componente['sku']}")
                else:
                    # Es un SKU individual (solo 1 componente con ventas)
                    # Se tratarÃ¡ como SKU no unificado
                    skus_no_unificados.append(producto_unificado)
                    # Marcar solo ese SKU como procesado
                    skus_ya_procesados.add(producto_unificado['sku'])
                    print(f"      âœ“ SKU individual (no unificado): {producto_unificado['sku']}")

    # 2. AÃ±adir otros SKUs no unificados de esta categorÃ­a
    for sku, sku_data in todos_los_skus.items():
        if (sku_data['categoria_original'] == categoria_objetivo and
            sku not in skus_ya_procesados and
            sku not in mapeo_inverso):
            skus_no_unificados.append(sku_data)

    # 3. Combinar productos unificados con no unificados para ordenar
    items_para_ordenar = []

    # AÃ±adir productos unificados
    for item in productos_unificados_de_categoria:
        items_para_ordenar.append(item['producto_unificado'])

    # AÃ±adir SKUs no unificados
    items_para_ordenar.extend(skus_no_unificados)

    # 4. Ordenar por ventas
    items_para_ordenar.sort(key=lambda x: x['ventas_reales'], reverse=True)

    # 5. Construir resultado final intercalando productos con sus componentes
    for item in items_para_ordenar:
        if item.get('es_producto_unificado', False):
            # Es un producto unificado, aÃ±adir el producto + sus componentes
            resultado_final.append(item)

            # Buscar los componentes de este producto especÃ­fico
            sku_principal = item['sku']
            for grupo in productos_unificados_de_categoria:
                if grupo['sku_principal'] == sku_principal:
                    # Ordenar componentes por ventas reales descendente antes de agregarlos
                    componentes_ordenados = sorted(
                        grupo['componentes'],
                        key=lambda x: x['ventas_reales'], reverse=True
                    )
                    # AÃ±adir componentes individuales para expansiÃ³n
                    for componente in componentes_ordenados:
                        componente_individual = componente.copy()
                        componente_individual['es_sku_componente'] = True
                        componente_individual['sku_principal'] = sku_principal
                        resultado_final.append(componente_individual)
                    break
        else:
            # Es un SKU no unificado, aÃ±adir tal como estÃ¡
            resultado_final.append(item)

    # 6. AÃ±adir totales al final
    resultado_final.extend(filas_totales)

    print(f"   âœ… Resultado final para {categoria_objetivo}: {len(resultado_final)} items")
    return resultado_final


def crear_producto_unificado(sku_principal, componentes):
    """
    Crea un producto unificado sumando las mÃ©tricas de todos sus componentes.
    SOLO unifica si hay 2 o mÃ¡s componentes con ventas.
    Si solo hay 1 componente con ventas, lo retorna como SKU individual.
    """
    if not componentes:
        return None

    # Filtrar componentes que tienen ventas reales
    componentes_con_ventas = [c for c in componentes if c.get('ventas_reales', 0) > 0]

    print(f"   ðŸ” Componentes totales: {len(componentes)}, con ventas: {len(componentes_con_ventas)}")

    # Si solo hay 1 componente con ventas, NO unificar
    if len(componentes_con_ventas) == 1:
        print(f"   âš ï¸ Solo 1 componente con ventas â†’ NO se unifica, se trata como SKU individual")
        componente_individual = componentes_con_ventas[0].copy()
        # Asegurarse de que NO tenga flags de producto unificado
        componente_individual['es_producto_unificado'] = False
        componente_individual['es_sku_componente'] = False
        componente_individual.pop('sku_principal', None)
        return componente_individual

    # Si no hay componentes con ventas, no crear nada
    if len(componentes_con_ventas) == 0:
        print(f"   âš ï¸ NingÃºn componente con ventas â†’ No se crea producto unificado")
        return None

    # Si hay 2 o mÃ¡s componentes con ventas, SÃ unificar
    print(f"   âœ… {len(componentes_con_ventas)} componentes con ventas â†’ SÃ se unifica")

    # Usar el primer componente como base
    producto_base = componentes_con_ventas[0].copy()

    # Sumar mÃ©tricas financieras SOLO de componentes con ventas (mes actual)
    ventas_totales = sum(c['ventas_reales'] for c in componentes_con_ventas)
    costo_venta_total = sum(c['costo_venta'] for c in componentes_con_ventas)
    gastos_directos_total = sum(c['gastos_directos'] for c in componentes_con_ventas)
    ingreso_real_total = sum(c['ingreso_real'] for c in componentes_con_ventas)
    transacciones_totales = sum(c['num_transacciones'] for c in componentes_con_ventas)

    # Obtener lista de TODOS los SKUs del producto unificado
    skus_todos_componentes = [sku_principal]
    if sku_principal in PRODUCTOS_UNIFICADOS:
        skus_todos_componentes.extend(PRODUCTOS_UNIFICADOS[sku_principal])

    print(f"   ðŸ“Š Buscando datos histÃ³ricos de {len(skus_todos_componentes)} componentes totales para calcular variaciones")

    # Buscar datos histÃ³ricos de TODOS los componentes
    ventas_anterior_total = 0.0
    costo_anterior_total = 0.0
    gastos_anteriores_total = 0.0
    ingreso_anterior_total = 0.0

    for componente in componentes_con_ventas:
        # Sumar datos histÃ³ricos de componentes que SÃ vendieron
        sku_comp = componente['sku']
        ventas_ant = componente.get('ventas_reales_anterior', 0)
        costo_ant = componente.get('costo_venta_anterior', 0)

        ventas_anterior_total += ventas_ant
        costo_anterior_total += costo_ant
        gastos_anteriores_total += componente.get('gastos_directos_anterior', 0)
        ingreso_anterior_total += componente.get('ingreso_real_anterior', 0)

        print(f"      ðŸ“Š Componente {sku_comp}: Sept ${componente['ventas_reales']:,.0f}, Ago ${ventas_ant:,.0f}, Costo Ago {(costo_ant/ventas_ant*100) if ventas_ant > 0 else 0:.1f}%")

    # Calcular variaciones de valores absolutos (%) - cambio en montos
    variacion_ventas_pct = ((ventas_totales - ventas_anterior_total) / ventas_anterior_total * 100) if ventas_anterior_total > 0 else 0.0
    variacion_costo_pct = ((costo_venta_total - costo_anterior_total) / costo_anterior_total * 100) if costo_anterior_total > 0 else 0.0
    variacion_gastos_pct = ((gastos_directos_total - gastos_anteriores_total) / abs(gastos_anteriores_total) * 100) if gastos_anteriores_total != 0 else 0.0

    # Calcular porcentajes del mes anterior para variaciones de ratios (puntos porcentuales)
    costo_porcentaje_anterior = (costo_anterior_total / ventas_anterior_total * 100) if ventas_anterior_total > 0 else 0.0
    gastos_porcentaje_anterior = (gastos_anteriores_total / ventas_anterior_total * 100) if ventas_anterior_total > 0 else 0.0
    ingreso_porcentaje_anterior = (ingreso_anterior_total / ventas_anterior_total * 100) if ventas_anterior_total > 0 else 0.0
    roi_porcentaje_anterior = (ingreso_anterior_total / costo_anterior_total * 100) if costo_anterior_total > 0 else 0.0

    # Actualizar el producto unificado
    producto_unificado = {
        'sku': sku_principal,
        'descripcion': producto_base['descripcion'],
        'ventas_reales': ventas_totales,
        'costo_venta': costo_venta_total,
        'gastos_directos': gastos_directos_total,
        'ingreso_real': ingreso_real_total,
        'num_transacciones': transacciones_totales,
        'skus_componentes': [c['sku'] for c in componentes_con_ventas],
        'es_producto_unificado': True,
        'es_fila_total': False,
        # Campos de variaciÃ³n temporal - valores absolutos
        'variacion_ventas_pct': variacion_ventas_pct,
        'variacion_costo_pct': variacion_costo_pct,
        'variacion_gastos_pct': variacion_gastos_pct,
        'periodo_comparacion': producto_base.get('periodo_comparacion', ''),
        # Campos histÃ³ricos
        'ventas_reales_anterior': ventas_anterior_total,
        'costo_venta_anterior': costo_anterior_total,
        'gastos_directos_anterior': gastos_anteriores_total,
        'ingreso_real_anterior': ingreso_anterior_total,
        'costo_venta_porcentaje_anterior': costo_porcentaje_anterior,
        'gastos_directos_porcentaje_anterior': gastos_porcentaje_anterior,
        'ingreso_real_porcentaje_anterior': ingreso_porcentaje_anterior,
        'roi_porcentaje_anterior': roi_porcentaje_anterior
    }

    # Recalcular promedios por unidad
    if transacciones_totales > 0:
        producto_unificado['ventas_reales_promedio'] = ventas_totales / transacciones_totales
        producto_unificado['costo_venta_promedio'] = costo_venta_total / transacciones_totales
        producto_unificado['gastos_directos_promedio'] = gastos_directos_total / transacciones_totales
        producto_unificado['ingreso_real_promedio'] = ingreso_real_total / transacciones_totales
    else:
        producto_unificado['ventas_reales_promedio'] = 0.0
        producto_unificado['costo_venta_promedio'] = 0.0
        producto_unificado['gastos_directos_promedio'] = 0.0
        producto_unificado['ingreso_real_promedio'] = 0.0

    # Recalcular porcentajes del mes actual
    if ventas_totales > 0:
        producto_unificado['costo_venta_porcentaje'] = (costo_venta_total / ventas_totales * 100)
        producto_unificado['gastos_directos_porcentaje'] = (gastos_directos_total / ventas_totales * 100)
        producto_unificado['ingreso_real_porcentaje'] = (ingreso_real_total / ventas_totales * 100)
    else:
        producto_unificado['costo_venta_porcentaje'] = 0.0
        producto_unificado['gastos_directos_porcentaje'] = 0.0
        producto_unificado['ingreso_real_porcentaje'] = 0.0

    # Recalcular ROI del mes actual
    if costo_venta_total > 0:
        producto_unificado['roi_porcentaje'] = (ingreso_real_total / costo_venta_total * 100)
    else:
        producto_unificado['roi_porcentaje'] = 0.0

    # Calcular variaciones de ratios (puntos porcentuales)
    costo_porcentaje_actual = producto_unificado['costo_venta_porcentaje']
    gastos_porcentaje_actual = producto_unificado['gastos_directos_porcentaje']
    ingreso_porcentaje_actual = producto_unificado['ingreso_real_porcentaje']
    roi_porcentaje_actual = producto_unificado['roi_porcentaje']

    producto_unificado['variacion_costo_venta_pct'] = costo_porcentaje_actual - costo_porcentaje_anterior
    producto_unificado['variacion_gastos_directos_pct'] = gastos_porcentaje_actual - gastos_porcentaje_anterior
    producto_unificado['variacion_ingreso_pct'] = ingreso_porcentaje_actual - ingreso_porcentaje_anterior
    producto_unificado['variacion_roi_pct'] = roi_porcentaje_actual - roi_porcentaje_anterior

    # Consolidar desgloses SOLO de componentes con ventas
    producto_unificado['desglose_canales'] = consolidar_desglose_canales(componentes_con_ventas)
    producto_unificado['desglose_meses'] = consolidar_desglose_meses(componentes_con_ventas)

    return producto_unificado


def consolidar_desglose_canales(componentes):
    """Consolida los desgloses por canal de todos los componentes."""
    if not componentes:
        return []

    print(f"ðŸ”— Consolidando desgloses por canal para {len(componentes)} componentes...")
    canales_consolidados = {}

    for componente in componentes:
        desglose_canales = componente.get('desglose_canales', [])

        for canal_data in desglose_canales:
            canal = canal_data.get('canal', 'Sin Canal')

            if canal not in canales_consolidados:
                canales_consolidados[canal] = {
                    'canal': canal, 'ventas_reales': 0.0, 'costo_venta': 0.0,
                    'gastos_directos': 0.0, 'ingreso_real': 0.0, 'num_transacciones': 0,
                    'ventas_reales_promedio': 0.0, 'costo_venta_promedio': 0.0,
                    'gastos_directos_promedio': 0.0, 'ingreso_real_promedio': 0.0,
                    'costo_venta_porcentaje': 0.0, 'gastos_directos_porcentaje': 0.0,
                    'ingreso_real_porcentaje': 0.0, 'roi_porcentaje': 0.0,
                    'variacion_ventas_pct': 0.0, 'variacion_costo_pct': 0.0,
                    'variacion_costo_venta_pct': 0.0, 'variacion_gastos_pct': 0.0,
                    'variacion_gastos_directos_pct': 0.0, 'variacion_ingreso_pct': 0.0,
                    'variacion_roi_pct': 0.0, 'periodo_comparacion': '',
                    'ventas_reales_anterior': 0.0, 'costo_venta_anterior': 0.0,
                    'gastos_directos_anterior': 0.0, 'ingreso_real_anterior': 0.0,
                    'costo_venta_porcentaje_anterior': 0.0, 'gastos_directos_porcentaje_anterior': 0.0,
                    'ingreso_real_porcentaje_anterior': 0.0, 'roi_porcentaje_anterior': 0.0
                }

            canal_acum = canales_consolidados[canal]
            canal_acum['ventas_reales'] += canal_data.get('ventas_reales', 0.0)
            canal_acum['costo_venta'] += canal_data.get('costo_venta', 0.0)
            canal_acum['gastos_directos'] += canal_data.get('gastos_directos', 0.0)
            canal_acum['ingreso_real'] += canal_data.get('ingreso_real', 0.0)
            canal_acum['num_transacciones'] += canal_data.get('num_transacciones', 0)
            canal_acum['ventas_reales_anterior'] += canal_data.get('ventas_reales_anterior', 0.0)
            canal_acum['costo_venta_anterior'] += canal_data.get('costo_venta_anterior', 0.0)
            canal_acum['gastos_directos_anterior'] += canal_data.get('gastos_directos_anterior', 0.0)
            canal_acum['ingreso_real_anterior'] += canal_data.get('ingreso_real_anterior', 0.0)

    # Recalcular mÃ©tricas
    for canal, data in canales_consolidados.items():
        # Promedios
        if data['num_transacciones'] > 0:
            data['ventas_reales_promedio'] = data['ventas_reales'] / data['num_transacciones']
            data['costo_venta_promedio'] = data['costo_venta'] / data['num_transacciones']
            data['gastos_directos_promedio'] = data['gastos_directos'] / data['num_transacciones']
            data['ingreso_real_promedio'] = data['ingreso_real'] / data['num_transacciones']

        # Porcentajes actuales
        if data['ventas_reales'] > 0:
            data['costo_venta_porcentaje'] = (data['costo_venta'] / data['ventas_reales'] * 100)
            data['gastos_directos_porcentaje'] = (data['gastos_directos'] / data['ventas_reales'] * 100)
            data['ingreso_real_porcentaje'] = (data['ingreso_real'] / data['ventas_reales'] * 100)
        if data['costo_venta'] > 0:
            data['roi_porcentaje'] = (data['ingreso_real'] / data['costo_venta'] * 100)

        # Porcentajes anteriores
        if data['ventas_reales_anterior'] > 0:
            data['costo_venta_porcentaje_anterior'] = (data['costo_venta_anterior'] / data['ventas_reales_anterior'] * 100)
            data['gastos_directos_porcentaje_anterior'] = (data['gastos_directos_anterior'] / data['ventas_reales_anterior'] * 100)
            data['ingreso_real_porcentaje_anterior'] = (data['ingreso_real_anterior'] / data['ventas_reales_anterior'] * 100)
        if data['costo_venta_anterior'] > 0:
            data['roi_porcentaje_anterior'] = (data['ingreso_real_anterior'] / data['costo_venta_anterior'] * 100)

        # Variaciones
        data['variacion_costo_venta_pct'] = data['costo_venta_porcentaje'] - data['costo_venta_porcentaje_anterior']
        data['variacion_gastos_directos_pct'] = data['gastos_directos_porcentaje'] - data['gastos_directos_porcentaje_anterior']
        data['variacion_ingreso_pct'] = data['ingreso_real_porcentaje'] - data['ingreso_real_porcentaje_anterior']
        data['variacion_roi_pct'] = data['roi_porcentaje'] - data['roi_porcentaje_anterior']

        if data['ventas_reales_anterior'] > 0:
            data['variacion_ventas_pct'] = ((data['ventas_reales'] - data['ventas_reales_anterior']) / data['ventas_reales_anterior'] * 100)

    resultado = list(canales_consolidados.values())
    resultado.sort(key=lambda x: x['ventas_reales'], reverse=True)
    return resultado


def consolidar_desglose_meses(componentes):
    """Consolida los desgloses por mes de todos los componentes."""
    if not componentes:
        return []

    print(f"ðŸ“… Consolidando desgloses por mes para {len(componentes)} componentes...")
    meses_consolidados = {}

    for componente in componentes:
        desglose_meses = componente.get('desglose_meses', [])

        for mes_data in desglose_meses:
            mes = mes_data.get('mes', 'Sin Mes')

            if mes not in meses_consolidados:
                meses_consolidados[mes] = {
                    'mes': mes, 'mes_corto': mes_data.get('mes_corto', ''),
                    'periodo': mes_data.get('periodo', ''), 'aÃ±o': mes_data.get('aÃ±o', 0),
                    'ventas_reales': 0.0, 'costo_venta': 0.0,
                    'gastos_directos': 0.0, 'ingreso_real': 0.0, 'num_transacciones': 0,
                    'ventas_reales_promedio': 0.0, 'costo_venta_promedio': 0.0,
                    'gastos_directos_promedio': 0.0, 'ingreso_real_promedio': 0.0,
                    'costo_venta_porcentaje': 0.0, 'gastos_directos_porcentaje': 0.0,
                    'ingreso_real_porcentaje': 0.0, 'roi_porcentaje': 0.0,
                    'dias_transcurridos': mes_data.get('dias_transcurridos', 0),
                    'total_dias_mes': mes_data.get('total_dias_mes', 0),
                    'variacion_ventas_pct': 0.0, 'variacion_costo_pct': 0.0,
                    'variacion_costo_venta_pct': 0.0, 'variacion_gastos_pct': 0.0,
                    'variacion_gastos_directos_pct': 0.0, 'variacion_ingreso_pct': 0.0,
                    'variacion_roi_pct': 0.0, 'periodo_comparacion': '',
                    'ventas_reales_anterior': 0.0, 'costo_venta_anterior': 0.0,
                    'gastos_directos_anterior': 0.0, 'ingreso_real_anterior': 0.0,
                    'costo_venta_porcentaje_anterior': 0.0, 'gastos_directos_porcentaje_anterior': 0.0,
                    'ingreso_real_porcentaje_anterior': 0.0, 'roi_porcentaje_anterior': 0.0
                }

            mes_acum = meses_consolidados[mes]
            mes_acum['ventas_reales'] += mes_data.get('ventas_reales', 0.0)
            mes_acum['costo_venta'] += mes_data.get('costo_venta', 0.0)
            mes_acum['gastos_directos'] += mes_data.get('gastos_directos', 0.0)
            mes_acum['ingreso_real'] += mes_data.get('ingreso_real', 0.0)
            mes_acum['num_transacciones'] += mes_data.get('num_transacciones', 0)
            mes_acum['ventas_reales_anterior'] += mes_data.get('ventas_reales_anterior', 0.0)
            mes_acum['costo_venta_anterior'] += mes_data.get('costo_venta_anterior', 0.0)
            mes_acum['gastos_directos_anterior'] += mes_data.get('gastos_directos_anterior', 0.0)
            mes_acum['ingreso_real_anterior'] += mes_data.get('ingreso_real_anterior', 0.0)

    # Recalcular mÃ©tricas
    for mes, data in meses_consolidados.items():
        # Promedios
        if data['num_transacciones'] > 0:
            data['ventas_reales_promedio'] = data['ventas_reales'] / data['num_transacciones']
            data['costo_venta_promedio'] = data['costo_venta'] / data['num_transacciones']
            data['gastos_directos_promedio'] = data['gastos_directos'] / data['num_transacciones']
            data['ingreso_real_promedio'] = data['ingreso_real'] / data['num_transacciones']

        # Porcentajes actuales
        if data['ventas_reales'] > 0:
            data['costo_venta_porcentaje'] = (data['costo_venta'] / data['ventas_reales'] * 100)
            data['gastos_directos_porcentaje'] = (data['gastos_directos'] / data['ventas_reales'] * 100)
            data['ingreso_real_porcentaje'] = (data['ingreso_real'] / data['ventas_reales'] * 100)
        if data['costo_venta'] > 0:
            data['roi_porcentaje'] = (data['ingreso_real'] / data['costo_venta'] * 100)

        # Porcentajes anteriores
        if data['ventas_reales_anterior'] > 0:
            data['costo_venta_porcentaje_anterior'] = (data['costo_venta_anterior'] / data['ventas_reales_anterior'] * 100)
            data['gastos_directos_porcentaje_anterior'] = (data['gastos_directos_anterior'] / data['ventas_reales_anterior'] * 100)
            data['ingreso_real_porcentaje_anterior'] = (data['ingreso_real_anterior'] / data['ventas_reales_anterior'] * 100)
        if data['costo_venta_anterior'] > 0:
            data['roi_porcentaje_anterior'] = (data['ingreso_real_anterior'] / data['costo_venta_anterior'] * 100)

        # Variaciones
        data['variacion_costo_venta_pct'] = data['costo_venta_porcentaje'] - data['costo_venta_porcentaje_anterior']
        data['variacion_gastos_directos_pct'] = data['gastos_directos_porcentaje'] - data['gastos_directos_porcentaje_anterior']
        data['variacion_ingreso_pct'] = data['ingreso_real_porcentaje'] - data['ingreso_real_porcentaje_anterior']
        data['variacion_roi_pct'] = data['roi_porcentaje'] - data['roi_porcentaje_anterior']

        if data['ventas_reales_anterior'] > 0:
            data['variacion_ventas_pct'] = ((data['ventas_reales'] - data['ventas_reales_anterior']) / data['ventas_reales_anterior'] * 100)

    resultado = list(meses_consolidados.values())
    try:
        resultado.sort(key=lambda x: x['mes'], reverse=True)
    except:
        resultado.sort(key=lambda x: x['ventas_reales'], reverse=True)
    return resultado


PRODUCTOS_UNIFICADOS = {
    '2000013': ['2000054', '2000057', '2000033'],  # Producto 1 + sus gemelos
    '2000005': ['2000032'],                        # Producto 2 + su gemelo  
    '9900157': ['2000059'],                        # Producto 3 + su gemelo
    '2000020': ['2000078']                         # Producto 4 + su gemelo
}

def unificar_productos_para_ranking(lista_skus):
    """
    Unifica productos gemelos SOLO para el ranking del index.
    NO modifica datos brutos ni afecta otras funcionalidades.
    
    Args:
        lista_skus: Lista de diccionarios con SKUs individuales
        
    Returns:
        Lista de diccionarios con productos unificados
    """
    if not lista_skus:
        return []
    
    print(f"DEBUG: Unificando productos. SKUs originales: {len(lista_skus)}")
    
    # Crear diccionario inverso para mapeo rÃ¡pido: sku_gemelo -> sku_principal
    mapeo_inverso = {}
    for sku_principal, gemelos in PRODUCTOS_UNIFICADOS.items():
        mapeo_inverso[sku_principal] = sku_principal  # El principal se mapea a sÃ­ mismo
        for gemelo in gemelos:
            mapeo_inverso[gemelo] = sku_principal
    
    # Agrupar SKUs por producto unificado
    productos_agrupados = {}
    skus_no_unificados = []
    
    for sku_data in lista_skus:
        sku_actual = sku_data['sku']
        
        if sku_actual in mapeo_inverso:
            # Este SKU pertenece a un producto unificado
            sku_principal = mapeo_inverso[sku_actual]
            
            if sku_principal not in productos_agrupados:
                # Primera vez que vemos este producto, usar datos del SKU principal o el primero que encontremos
                productos_agrupados[sku_principal] = {
                    'sku': sku_principal,
                    'descripcion': sku_data['descripcion'],
                    'unidades': sku_data['unidades'],
                    'monto': sku_data['monto'],
                    'skus_componentes': [sku_actual],
                    'precio_promedio': sku_data['precio_promedio']
                }
            else:
                # Ya existe, sumar las mÃ©tricas
                productos_agrupados[sku_principal]['unidades'] += sku_data['unidades']
                productos_agrupados[sku_principal]['monto'] += sku_data['monto']
                productos_agrupados[sku_principal]['skus_componentes'].append(sku_actual)
                
                # Recalcular precio promedio
                total_unidades = productos_agrupados[sku_principal]['unidades']
                total_monto = productos_agrupados[sku_principal]['monto']
                productos_agrupados[sku_principal]['precio_promedio'] = total_monto / total_unidades if total_unidades > 0 else 0
        else:
            # SKU no estÃ¡ en la lista de unificaciÃ³n, mantener como estÃ¡
            skus_no_unificados.append(sku_data)
    
    # Combinar productos unificados con los no unificados
    resultado_final = list(productos_agrupados.values()) + skus_no_unificados
    
    # Reordenar por unidades vendidas (descendente)
    resultado_final.sort(key=lambda x: x['unidades'], reverse=True)
    
    print(f"DEBUG: Productos despuÃ©s de unificar: {len(resultado_final)}")
    print(f"DEBUG: Productos unificados: {len(productos_agrupados)}")
    
    return resultado_final

def obtener_todas_clasificaciones_optimizado(aÃ±o=None, mes=None):
    """
    FunciÃ³n SÃšPER OPTIMIZADA: Obtiene todas las clasificaciones en UNA SOLA consulta

    Args:
        aÃ±o: AÃ±o especÃ­fico (opcional, default: aÃ±o actual)
        mes: Mes especÃ­fico (opcional, default: mes actual)

    Returns:
        Diccionario con SKUs agrupados por clasificaciÃ³n:
        {
            'Estrella': [lista de SKUs],
            'Prometedores': [lista de SKUs],
            'Potenciales': [lista de SKUs]
        }
    """
    from datetime import datetime
    import time

    # Valores por defecto
    if aÃ±o is None:
        aÃ±o = datetime.now().year
    if mes is None:
        mes = datetime.now().month

    # Mapeo de nomenclatura ClickHouse -> Python
    MAPEO_CLASIFICACIONES = {
        'Estrellas': 'Estrella',       # Revertido: mantener mapeo que funcionaba
        'Prometedores': 'Prometedores',
        'Potenciales': 'Potenciales',
        'Revision': 'Revision',        # Sin acento en ambos lados
        'Remover': 'Remover'
    }

    # Mapeo de colores y orden
    COLORES_CLASIFICACION = {
        'Estrella': ('#D4AF37', 1),     # Dorado - Revertido al funcionamiento original
        'Prometedores': ('#28a745', 2), # Verde
        'Potenciales': ('#17a2b8', 3),  # Azul
        'Revision': ('#fd7e14', 4),     # Naranja - Sin acento
        'Remover': ('#e63946', 5)       # Rojo
    }

    try:
        tiempo_inicio = time.time()
        print(f"=== CONSULTA ÃšNICA OPTIMIZADA ClickHouse PARA {mes}/{aÃ±o} ===")
        print(f"ðŸŽ¯ Obteniendo TOP 100 SKUs de todas las clasificaciones prioritarias")

        # Construir filtros de consulta
        anio_mes = f"{aÃ±o}-{mes:02d}"

        # Query OPTIMIZADA: Una consulta para todas las clasificaciones
        query = f"""
        SELECT
            sku,
            descripcion,
            marca,
            categoria,
            canal_principal,
            cantidad_vendida,
            numero_ordenes,
            clasificacion,
            umbral_aplicado,
            es_mes_actual,
            dias_transcurridos
        FROM Silver.Clasificacion_SKU
        WHERE anio_mes = '{anio_mes}'
        AND clasificacion IN ('Estrellas', 'Prometedores', 'Potenciales', 'Revision', 'Remover')
        ORDER BY cantidad_vendida DESC
        LIMIT 100
        """

        print(f"Ejecutando query optimizada: {query}")

        # Ejecutar consulta
        connection = get_db_connection()
        result = connection.query(query)
        rows = result.result_rows

        tiempo_query = time.time()
        print(f"â±ï¸  Query ClickHouse ÃšNICA ejecutada en: {tiempo_query - tiempo_inicio:.3f} segundos")
        print(f"ðŸ“Š Total SKUs obtenidos: {len(rows)}")

        # DEBUG: Mostrar quÃ© clasificaciones llegan de la DB
        clasificaciones_db = set()
        for row in rows:
            clasificaciones_db.add(row[7])  # clasificacion
        print(f"ðŸ” DEBUG: Clasificaciones encontradas en DB: {sorted(list(clasificaciones_db))}")

        # Agrupar por clasificaciÃ³n
        clasificaciones_agrupadas = {
            'Estrella': [],
            'Prometedores': [],
            'Potenciales': [],
            'Revision': [],
            'Remover': []
        }

        contadores_clasificacion = {
            "Estrella": 0,
            "Prometedores": 0,
            "Potenciales": 0,
            "Revision": 0,
            "Remover": 0
        }

        for row in rows:
            # Mapear clasificaciÃ³n de ClickHouse a Python
            clasificacion_clickhouse = row[7]  # clasificacion
            clasificacion_python = MAPEO_CLASIFICACIONES.get(clasificacion_clickhouse, clasificacion_clickhouse)

            # DEBUG: Mostrar mapeo individual (comentado para reducir ruido)
            # if clasificacion_clickhouse in ['Revision', 'Remover']:
            #     print(f"ðŸ” DEBUG: Mapeando '{clasificacion_clickhouse}' â†’ '{clasificacion_python}'")

            # Solo procesar clasificaciones prioritarias
            if clasificacion_python not in clasificaciones_agrupadas:
                print(f"âš ï¸ DEBUG: ClasificaciÃ³n '{clasificacion_python}' no encontrada en agrupadas: {list(clasificaciones_agrupadas.keys())}")
                continue

            # Obtener color y orden
            color, orden = COLORES_CLASIFICACION.get(clasificacion_python, ('#6c757d', 6))

            # Contar por clasificaciÃ³n
            contadores_clasificacion[clasificacion_python] += 1

            sku_data = {
                'sku': row[0],                          # sku
                'descripcion': row[1],                  # descripcion
                'marca': row[2],                        # marca
                'categoria': row[3],                    # categoria
                'canal_principal': row[4],              # canal_principal
                'cantidad_mensual': int(row[5]),        # cantidad_vendida
                'numero_ordenes': int(row[6]),          # numero_ordenes
                'clasificacion': clasificacion_python,  # clasificacion mapeada
                'color': color,
                'orden': orden,
                'umbral_aplicado': float(row[8]),       # umbral_aplicado
                'es_mes_actual': bool(row[9]),          # es_mes_actual
                'dias_transcurridos': int(row[10])      # dias_transcurridos
            }

            # Agregar a la clasificaciÃ³n correspondiente
            clasificaciones_agrupadas[clasificacion_python].append(sku_data)

        tiempo_final = time.time()
        print(f"â±ï¸  Procesamiento total OPTIMIZADO: {tiempo_final - tiempo_inicio:.3f} segundos")

        # Mostrar resumen
        print(f"=== RESUMEN OPTIMIZADO (1 CONSULTA) ===")
        for clasificacion, cantidad in contadores_clasificacion.items():
            if cantidad > 0:
                print(f"{clasificacion}: {cantidad} SKUs")

        return clasificaciones_agrupadas

    except Exception as e:
        print(f"âŒ ERROR en consulta optimizada: {e}")
        # Fallback: retornar diccionario vacÃ­o
        return {
            'Estrella': [],
            'Prometedores': [],
            'Potenciales': []
        }

def obtener_ingreso_ideal_sku_canal():
    """
    Consulta la tabla Silver.categorizacion_ingreso para obtener datos de Ingreso Ideal

    Estructura de la tabla:
    - Canal: String (canal de venta)
    - sku: String (SKU del producto)
    - IR_Base: UInt16 (Ingreso Real base en %, ej: 35 = 35%)
    - Competencia: UInt8 (Ajuste por competencia en puntos, puede ser negativo)
    - Diferenciador: UInt8 (Ajuste por diferenciaciÃ³n en puntos positivos)
    - Calidad: UInt8 (Ajuste por calidad en puntos positivos)
    - Percepcion: UInt8 (Ajuste por percepciÃ³n en puntos positivos)
    - Funcionalidad: UInt8 (Ajuste por funcionalidad en puntos positivos)
    - IR_Final: UInt16 (Ingreso Real ideal/objetivo en %, ej: 40 = 40%)
    - Precio: UInt32 (Precio ideal en pesos, ej: 450 = $450)
    - IRxUnidad: UInt32 (Ingreso Real por unidad en pesos, ej: 180 = $180)

    Returns:
        Dict[str, Dict[str, dict]]: {sku: {canal: {datos_ingreso_ideal}}}
        Ejemplo: {'SKU-001': {'Mercado Libre': {'ir_base': 35.0, 'ir_final': 40.0, ...}}}
    """
    import time

    try:
        tiempo_inicio = time.time()
        print(f"ðŸ“Š Consultando Silver.categorizacion_ingreso para Ingreso Ideal...")

        connection = get_db_connection()

        query = """
        SELECT
            Canal,
            sku,
            IR_Base,
            Competencia,
            Diferenciador,
            Calidad,
            Percepcion,
            Funcionalidad,
            IR_Final,
            Precio,
            IRxUnidad
        FROM Silver.categorizacion_ingreso
        ORDER BY Canal, sku
        """

        result = connection.query(query)
        rows = result.result_rows

        tiempo_query = time.time()
        print(f"â±ï¸  Query categorizacion_ingreso ejecutada en: {tiempo_query - tiempo_inicio:.3f} segundos")
        print(f"ðŸ“Š Total registros obtenidos: {len(rows)}")

        # Estructurar datos por SKU y Canal
        datos_ideal = {}
        skus_unicos = set()
        canales_unicos = set()

        for row in rows:
            canal = row[0]
            sku = row[1]

            skus_unicos.add(sku)
            canales_unicos.add(canal)

            if sku not in datos_ideal:
                datos_ideal[sku] = {}

            # Los valores ya vienen en la escala correcta (35 = 35%, 450 = $450)
            datos_ideal[sku][canal] = {
                'ir_base': float(row[2]),              # Ya es 35.0 para 35%
                'competencia': float(row[3]),          # Ya es 2.0 para 2 puntos
                'diferenciador': float(row[4]),        # Ya es 3.0 para 3 puntos
                'calidad': float(row[5]),              # Ya es 2.0 para 2 puntos
                'percepcion': float(row[6]),           # Ya es 1.0 para 1 punto
                'funcionalidad': float(row[7]),        # Ya es 1.5 para 1.5 puntos
                'ir_final': float(row[8]),             # Ya es 40.0 para 40%
                'precio_ideal': float(row[9]),         # Ya es 450.0 para $450
                'ir_por_unidad': float(row[10])        # Ya es 180.0 para $180
            }

        tiempo_final = time.time()
        print(f"â±ï¸  Procesamiento Ingreso Ideal completado en: {tiempo_final - tiempo_inicio:.3f} segundos")
        print(f"âœ… Ingreso Ideal cargado: {len(skus_unicos)} SKUs Ãºnicos, {len(canales_unicos)} canales Ãºnicos")
        print(f"âœ… Total combinaciones SKUÃ—Canal: {sum(len(v) for v in datos_ideal.values())}")

        return datos_ideal

    except Exception as e:
        print(f"âŒ Error consultando Silver.categorizacion_ingreso: {e}")
        import traceback
        traceback.print_exc()
        # Retornar diccionario vacÃ­o en caso de error
        return {}

def obtener_skus_por_clasificacion_clickhouse(clasificacion, aÃ±o=None, mes=None):
    """
    FunciÃ³n optimizada para obtener SKUs de una clasificaciÃ³n especÃ­fica desde ClickHouse

    Args:
        clasificacion: 'Estrella', 'Prometedores', 'Potenciales', etc.
        aÃ±o: AÃ±o especÃ­fico (opcional, default: aÃ±o actual)
        mes: Mes especÃ­fico (opcional, default: mes actual)

    Returns:
        Lista de SKUs de la clasificaciÃ³n solicitada
    """
    # Mapear clasificaciÃ³n Python -> ClickHouse
    MAPEO_INVERSO = {
        'Estrella': 'Estrellas',
        'Prometedores': 'Prometedores',
        'Potenciales': 'Potenciales',
        'RevisiÃ³n': 'Revision',
        'Remover': 'Remover'
    }

    clasificacion_clickhouse = MAPEO_INVERSO.get(clasificacion, clasificacion)

    # Consultar ClickHouse con filtro especÃ­fico
    resultados = obtener_clasificaciones_desde_clickhouse(
        aÃ±o=aÃ±o,
        mes=mes,
        clasificaciones_filtro=[clasificacion_clickhouse]
    )

    print(f"ðŸ“Š SKUs {clasificacion} obtenidos desde ClickHouse: {len(resultados)}")
    return resultados

def calcular_mes_anterior(aÃ±o, mes):
    """Calcula el aÃ±o y mes anterior"""
    if mes == 1:
        return aÃ±o - 1, 12
    else:
        return aÃ±o, mes - 1

def resumen_clasificaciones_con_participacion(clasificaciones_actual):
    """Genera resumen de clasificaciones con porcentaje de participaciÃ³n en ventas"""
    # Agrupar por clasificaciÃ³n y calcular totales
    agrupaciones = {}
    total_ventas_mes = 0
    
    for item in clasificaciones_actual:
        clasificacion = item['clasificacion']
        monto_mensual = item['monto_mensual']
        
        if clasificacion not in agrupaciones:
            agrupaciones[clasificacion] = {
                'clasificacion': clasificacion,
                'cantidad_skus': 0,
                'total_monto': 0
            }
        
        agrupaciones[clasificacion]['cantidad_skus'] += 1
        agrupaciones[clasificacion]['total_monto'] += monto_mensual
        total_ventas_mes += monto_mensual
    
    # Colores para cada clasificaciÃ³n - Paleta mejorada
    colores = {
        "Estrella": "#D4AF37", "Prometedores": "#28a745", "Potenciales": "#17a2b8",
        "RevisiÃ³n": "#fd7e14", "Remover": "#e63946"
    }
    
    # Orden de clasificaciones
    orden_clasificaciones = ["Estrella", "Prometedores", "Potenciales", "RevisiÃ³n", "Remover"]
    
    resumen = []
    total_porcentaje_verificacion = 0
    
    for clasificacion in orden_clasificaciones:
        if clasificacion in agrupaciones:
            data = agrupaciones[clasificacion]
            porcentaje = (data['total_monto'] / total_ventas_mes * 100) if total_ventas_mes > 0 else 0
            total_porcentaje_verificacion += porcentaje
            
            resumen.append({
                'clasificacion': clasificacion,
                'color': colores[clasificacion],
                'cantidad_actual': data['cantidad_skus'],
                'porcentaje_participacion': porcentaje,
                'diferencia': f"{porcentaje:.1f}%",  # Ahora muestra el porcentaje de participaciÃ³n
                'delta': porcentaje  # Usar el porcentaje para el color (todos serÃ¡n positivos)
            })
        else:
            # Si no hay SKUs en esta clasificaciÃ³n
            resumen.append({
                'clasificacion': clasificacion,
                'color': colores[clasificacion],
                'cantidad_actual': 0,
                'porcentaje_participacion': 0,
                'diferencia': "0.0%",
                'delta': 0
            })
    
    print(f"=== VERIFICACIÃ“N PORCENTAJES ===")
    print(f"Total ventas del mes: ${total_ventas_mes:,.0f}")
    print(f"Suma de porcentajes: {total_porcentaje_verificacion:.1f}%")
    
    return resumen

# FUNCIONES PARA DATOS FRESCOS
def analizar_estructura_tabla_fuente():
    """FunciÃ³n temporal para analizar la estructura completa de RPT_Ventas_Con_Costo"""
    client = get_db_connection()
    if not client:
        return None

    try:
        print("ðŸ” ANALIZANDO ESTRUCTURA DE TABLA RPT_Ventas_Con_Costo...")

        # Consultar estructura de la tabla
        describe_query = "DESCRIBE RPT_Ventas_Con_Costo"
        describe_result = client.query(describe_query)
        columns_info = describe_result.result_rows

        print(f"ðŸ“Š CAMPOS DISPONIBLES EN RPT_Ventas_Con_Costo:")
        print("=" * 70)
        for i, (column_name, column_type, default_value, *other) in enumerate(columns_info, 1):
            print(f"{i:2d}. {column_name:<25} | {column_type:<20}")
        print("=" * 70)

        # TambiÃ©n obtener una muestra de datos para ver valores reales
        sample_query = "SELECT * FROM RPT_Ventas_Con_Costo LIMIT 1"
        sample_result = client.query(sample_query)

        if sample_result.result_rows:
            print(f"\nðŸ“‹ MUESTRA DE DATOS (primera fila):")
            print("-" * 70)
            sample_row = sample_result.result_rows[0]
            column_names = sample_result.column_names

            for i, (col_name, value) in enumerate(zip(column_names, sample_row), 1):
                print(f"{i:2d}. {col_name:<25} = {str(value)[:40]}")
            print("-" * 70)

        return columns_info, sample_result.column_names if sample_result.result_rows else []

    except Exception as e:
        print(f"âŒ Error analizando estructura: {e}")
        return None

# FUNCIONES ESPECÃFICAS PARA PESTAÃ‘A DE RENTABILIDAD
def cargar_acumulado_mensual_matriz():
    """
    Carga datos de la vista Silver.RPT_Ventas_Acumulado_Mensual_SKU_Canal
    Vista con datos acumulados dÃ­a a dÃ­a dentro de cada mes por SKU y Canal
    """
    from datetime import datetime
    from dateutil.relativedelta import relativedelta
    import time
    import sys

    tiempo_funcion_inicio = time.time()
    print(f"ðŸ” [PERFORMANCE] INICIO - cargar_acumulado_mensual_matriz()")
    sys.stdout.flush()

    tiempo_conexion_inicio = time.time()
    client = get_db_connection()
    tiempo_conexion_fin = time.time()
    print(f"â±ï¸  [PERFORMANCE] ConexiÃ³n BD: {tiempo_conexion_fin - tiempo_conexion_inicio:.3f} segundos")
    sys.stdout.flush()

    if not client:
        return pd.DataFrame(), [], []

    try:
        hoy = datetime.now()
        print(f"INFO: [MATRIZ] Cargando datos acumulados desde {hoy.strftime('%Y-%m-%d')}")

        # Query para cargar la vista completa (o filtrar por perÃ­odo si es necesario)
        tiempo_query_inicio = time.time()
        query = """
        SELECT
            Fecha,
            sku,
            Descripcion,
            Marca,
            Categoria,
            Channel,
            Cantidad,
            Ventas AS Total,
            Costo AS "Costo de venta",
            Comision,
            Gastos_Destino,
            Ultima_milla,
            Gastos_Directos AS Gastos_directos,
            Ingreso_real AS "Ingreso real",
            Costo_Pct,
            Gastos_Directos_Pct,
            Ingreso_Real_Pct,
            ROI_Pct,
            Ordenes,
            Clasificacion,
            'Activo' AS estado
        FROM Silver.RPT_Ventas_Acumulado_Mensual_SKU_Canal
        WHERE toYear(Fecha) = toYear(today())
        ORDER BY Fecha DESC, sku ASC
        """

        print(f"INFO: [MATRIZ] Ejecutando query para vista acumulada...")
        sys.stdout.flush()
        tiempo_ejecucion_inicio = time.time()
        result = client.query(query)
        tiempo_ejecucion_fin = time.time()
        print(f"â±ï¸  [PERFORMANCE] EjecuciÃ³n query BD: {tiempo_ejecucion_fin - tiempo_ejecucion_inicio:.3f} segundos")
        sys.stdout.flush()

        if not result.result_rows:
            print("WARNING: [MATRIZ] No se encontraron datos en la vista")
            return pd.DataFrame(), [], []

        # Convertir a DataFrame
        tiempo_dataframe_inicio = time.time()
        df = pd.DataFrame(result.result_rows, columns=result.column_names)
        df['Fecha'] = pd.to_datetime(df['Fecha'])

        tiempo_dataframe_fin = time.time()
        print(f"â±ï¸  [PERFORMANCE] ConversiÃ³n a DataFrame: {tiempo_dataframe_fin - tiempo_dataframe_inicio:.3f} segundos")
        sys.stdout.flush()

        # Obtener listas de canales disponibles
        tiempo_listas_inicio = time.time()
        channels_disponibles = sorted(df['Channel'].unique().tolist())
        marcas_disponibles = sorted(df['Marca'].unique().tolist())
        tiempo_listas_fin = time.time()
        print(f"â±ï¸  [PERFORMANCE] GeneraciÃ³n listas: {tiempo_listas_fin - tiempo_listas_inicio:.3f} segundos")
        sys.stdout.flush()

        tiempo_query_fin = time.time()
        print(f"â±ï¸  [PERFORMANCE] Query TOTAL: {tiempo_query_fin - tiempo_query_inicio:.3f} segundos")

        tiempo_funcion_fin = time.time()
        print(f"ðŸ” [PERFORMANCE] FIN - cargar_acumulado_mensual_matriz(): {tiempo_funcion_fin - tiempo_funcion_inicio:.3f} segundos")
        sys.stdout.flush()

        print(f"SUCCESS: [MATRIZ] Cargados {len(df):,} registros")
        print(f"INFO: [MATRIZ] Canales encontrados: {len(channels_disponibles)}")
        print(f"INFO: [MATRIZ] Marcas encontradas: {len(marcas_disponibles)}")

        # Verificar que la columna Clasificacion existe
        if 'Clasificacion' in df.columns:
            clasificaciones_unicas = df['Clasificacion'].unique()
            print(f"INFO: [MATRIZ] Clasificaciones encontradas: {clasificaciones_unicas}")
            print(f"INFO: [MATRIZ] Registros con clasificaciÃ³n: {df['Clasificacion'].notna().sum()}")
        else:
            print(f"WARNING: [MATRIZ] Columna 'Clasificacion' NO encontrada en el DataFrame")

        sys.stdout.flush()

        return df, channels_disponibles, marcas_disponibles

    except Exception as e:
        print(f"ERROR: [MATRIZ] Error al cargar datos acumulados: {str(e)}")
        import traceback
        traceback.print_exc()
        sys.stdout.flush()
        return pd.DataFrame(), [], []

def cargar_ultimos_3_meses_rentabilidad():
    """
    SOLO PARA ANÃLISIS DE RENTABILIDAD
    Carga datos optimizados de los Ãºltimos 3 meses para desglose temporal
    Ejemplo: Si estamos en Sep 2024, carga Jul, Ago, Sep 2024
    """
    from datetime import datetime
    from dateutil.relativedelta import relativedelta
    import time
    import sys

    tiempo_funcion_inicio = time.time()
    print(f"ðŸ” [PERFORMANCE] INICIO - cargar_ultimos_3_meses_rentabilidad()")
    sys.stdout.flush()

    tiempo_conexion_inicio = time.time()
    client = get_db_connection()
    tiempo_conexion_fin = time.time()
    print(f"â±ï¸  [PERFORMANCE] ConexiÃ³n BD: {tiempo_conexion_fin - tiempo_conexion_inicio:.3f} segundos")
    sys.stdout.flush()

    if not client:
        return pd.DataFrame(), [], []

    try:
        hoy = datetime.now()
        print(f"INFO: [RENTABILIDAD] Cargando datos de Ãºltimos 3 meses desde {hoy.strftime('%Y-%m-%d')}")

        # Calcular los 3 meses a cargar
        meses_condiciones = []
        meses_info = []

        for i in range(3):
            fecha_mes = hoy.replace(day=1) - relativedelta(months=i)
            aÃ±o = fecha_mes.year
            mes = fecha_mes.month

            meses_condiciones.append(f"(toYear(Fecha) = {aÃ±o} AND toMonth(Fecha) = {mes})")
            meses_info.append(f"{aÃ±o}-{mes:02d}")

        print(f"INFO: [RENTABILIDAD] Meses a cargar: {', '.join(meses_info)}")

        # Query optimizada para 3 meses especÃ­ficos + canales oficiales
        tiempo_query_inicio = time.time()
        query = f"""
        SELECT * FROM RPT_Ventas_Con_Costo
        WHERE ({' OR '.join(meses_condiciones)})
        AND Channel IN ({','.join([f"'{canal}'" for canal in CANALES_CLASIFICACION])})
        ORDER BY Fecha DESC
        """

        print(f"INFO: [RENTABILIDAD] Ejecutando query optimizada para 3 meses...")
        sys.stdout.flush()
        tiempo_ejecucion_inicio = time.time()
        result = client.query(query)
        tiempo_ejecucion_fin = time.time()
        print(f"â±ï¸  [PERFORMANCE] EjecuciÃ³n query BD: {tiempo_ejecucion_fin - tiempo_ejecucion_inicio:.3f} segundos")
        sys.stdout.flush()

        if not result.result_rows:
            print("WARNING: [RENTABILIDAD] No se encontraron datos para los Ãºltimos 3 meses")
            return pd.DataFrame(), [], []

        # Convertir a DataFrame
        tiempo_dataframe_inicio = time.time()
        df = pd.DataFrame(result.result_rows, columns=result.column_names)
        df['Fecha'] = pd.to_datetime(df['Fecha'])

        # IMPORTANTE: Convertir cantidad a numÃ©rico desde el inicio
        if 'cantidad' in df.columns:
            print(f"DEBUG: Convirtiendo columna 'cantidad' a numÃ©rico en carga inicial")
            print(f"DEBUG: Tipo original: {df['cantidad'].dtype}")
            df['cantidad'] = pd.to_numeric(df['cantidad'], errors='coerce').fillna(0)
            print(f"DEBUG: Tipo despuÃ©s de conversiÃ³n: {df['cantidad'].dtype}")
            print(f"DEBUG: Registros con cantidad vÃ¡lida: {(df['cantidad'] > 0).sum()} de {len(df)}")
        else:
            print(f"WARNING: Columna 'cantidad' no encontrada en los datos de ClickHouse")

        tiempo_dataframe_fin = time.time()
        print(f"â±ï¸  [PERFORMANCE] ConversiÃ³n a DataFrame: {tiempo_dataframe_fin - tiempo_dataframe_inicio:.3f} segundos")
        sys.stdout.flush()

        # Obtener listas de canales y warehouses disponibles
        tiempo_listas_inicio = time.time()
        channels_disponibles = sorted(df['Channel'].unique().tolist())
        warehouses_disponibles = sorted(df['Warehouse'].unique().tolist())
        tiempo_listas_fin = time.time()
        print(f"â±ï¸  [PERFORMANCE] GeneraciÃ³n listas: {tiempo_listas_fin - tiempo_listas_inicio:.3f} segundos")
        sys.stdout.flush()

        tiempo_query_fin = time.time()
        print(f"â±ï¸  [PERFORMANCE] Query TOTAL: {tiempo_query_fin - tiempo_query_inicio:.3f} segundos")

        tiempo_funcion_fin = time.time()
        print(f"ðŸ” [PERFORMANCE] FIN - cargar_ultimos_3_meses_rentabilidad(): {tiempo_funcion_fin - tiempo_funcion_inicio:.3f} segundos")
        sys.stdout.flush()

        print(f"SUCCESS: [RENTABILIDAD] Cargados {len(df):,} registros de {len(df['Fecha'].dt.to_period('M').unique())} meses")
        print(f"INFO: [RENTABILIDAD] Canales encontrados: {len(channels_disponibles)}")
        print(f"INFO: [RENTABILIDAD] Warehouses encontrados: {len(warehouses_disponibles)}")

        return df, channels_disponibles, warehouses_disponibles

    except Exception as e:
        print(f"ERROR: [RENTABILIDAD] Error cargando datos de 3 meses: {e}")
        return pd.DataFrame(), [], []

def filtrar_por_mes_actual_rentabilidad(df_completo, mes_seleccionado):
    """
    SOLO PARA ANÃLISIS DE RENTABILIDAD
    Filtra el DataFrame completo para obtener solo el mes actual
    Usado para mÃ©tricas principales que no necesitan desglose temporal
    """
    if df_completo.empty:
        return df_completo

    # Filtrar por el mes especÃ­fico
    df_filtrado = df_completo[df_completo['Fecha'].dt.month == mes_seleccionado].copy()

    print(f"INFO: [RENTABILIDAD] Filtrado {len(df_completo):,} â†’ {len(df_filtrado):,} registros para mes {mes_seleccionado}")

    return df_filtrado

def calcular_variaciones_temporales_skus(df_completo, skus_list):
    """
    Calcula las variaciones temporales para una lista de SKUs siguiendo la misma lÃ³gica que canales
    Args:
        df_completo: DataFrame con datos completos (incluye mes anterior)
        skus_list: Lista de SKUs para calcular variaciones
    Returns:
        dict: Diccionario con datos del mes anterior por SKU {sku: {metricas_anteriores}}
    """
    from datetime import datetime, date
    import calendar

    if df_completo.empty or not skus_list:
        return {}

    print(f"ðŸ” Calculando variaciones temporales para {len(skus_list)} SKUs...")

    # Normalizar fechas del DataFrame completo
    df_completo_naive = df_completo.copy()
    if 'Fecha' in df_completo_naive.columns:
        df_completo_naive["Fecha"] = pd.to_datetime(df_completo_naive["Fecha"]).dt.tz_localize(None)

    # Determinar el perÃ­odo de comparaciÃ³n basado en dÃ­as transcurridos (igual que canales)
    hoy = date.today()
    fecha_actual = datetime.now()
    mes_actual = fecha_actual.month
    aÃ±o_actual = fecha_actual.year

    # Calcular dÃ­as transcurridos del perÃ­odo actual
    if mes_actual == hoy.month and aÃ±o_actual == hoy.year:
        # Estamos en el mes actual - usar dÃ­as transcurridos
        dias_transcurridos = hoy.day

        # PerÃ­odo anterior: mismos dÃ­as del mes anterior
        if mes_actual > 1:
            mes_anterior = mes_actual - 1
            aÃ±o_anterior = aÃ±o_actual
        else:
            mes_anterior = 12
            aÃ±o_anterior = aÃ±o_actual - 1

        f1_anterior = datetime(aÃ±o_anterior, mes_anterior, 1)
        f2_anterior = datetime(aÃ±o_anterior, mes_anterior, dias_transcurridos)

        periodo_comparacion = f"vs mismos {dias_transcurridos} dÃ­as de {f1_anterior.strftime('%B %Y')}"
        print(f"COMPARACIÃ“N SKUs: {dias_transcurridos} dÃ­as transcurridos")

    else:
        # Mes completo - usar todo el mes anterior
        ultimo_dia_mes = calendar.monthrange(mes_actual, aÃ±o_actual)[1]
        dias_transcurridos = ultimo_dia_mes

        if mes_actual > 1:
            mes_anterior = mes_actual - 1
            aÃ±o_anterior = aÃ±o_actual
        else:
            mes_anterior = 12
            aÃ±o_anterior = aÃ±o_actual - 1

        f1_anterior = datetime(aÃ±o_anterior, mes_anterior, 1)
        f2_anterior = datetime(aÃ±o_anterior, mes_anterior, calendar.monthrange(aÃ±o_anterior, mes_anterior)[1])

        periodo_comparacion = f"vs {f1_anterior.strftime('%B %Y')}"
        print(f"COMPARACIÃ“N SKUs: mes completo")

    # Filtrar datos del perÃ­odo anterior para los SKUs especificados
    try:
        ventas_periodo_anterior = df_completo_naive[
            (df_completo_naive["Fecha"] >= f1_anterior) &
            (df_completo_naive["Fecha"] <= f2_anterior) &
            (df_completo_naive["estado"] != "Cancelado") &
            (df_completo_naive['Channel'].isin(CANALES_CLASIFICACION)) &
            (df_completo_naive['sku'].isin(skus_list))
        ].copy()

        print(f"âœ… VARIACIONES SKUs: {len(ventas_periodo_anterior)} registros del perÃ­odo anterior obtenidos")

        if not ventas_periodo_anterior.empty:
            # Calcular mÃ©tricas por SKU del mes anterior usando campos pre-calculados
            ventas_por_sku_anterior = ventas_periodo_anterior.groupby(['sku']).agg({
                'Total': 'sum',                    # Ventas totales
                'Costo de venta': 'sum',          # Costo de venta (ya con IVA)
                'Gastos_directos': 'sum',         # PRE-CALCULADO EN CLICKHOUSE
                'Ingreso real': 'sum',            # PRE-CALCULADO EN CLICKHOUSE
                'cantidad': 'sum',
                'estado': 'count'
            }).reset_index()

            # Calcular porcentajes ponderados para el perÃ­odo anterior
            ventas_por_sku_anterior['Ingreso_Real_Porcentaje_Anterior'] = (
                ventas_por_sku_anterior['Ingreso real'] / ventas_por_sku_anterior['Total'] * 100
            ).fillna(0)

            ventas_por_sku_anterior['Costo_Venta_Porcentaje_Anterior'] = (
                ventas_por_sku_anterior['Costo de venta'] / ventas_por_sku_anterior['Total'] * 100
            ).fillna(0)

            ventas_por_sku_anterior['Gastos_Directos_Porcentaje_Anterior'] = (
                ventas_por_sku_anterior['Gastos_directos'] / ventas_por_sku_anterior['Total'] * 100
            ).fillna(0)

            # âœ… NUEVO: Calcular ROI porcentaje para el perÃ­odo anterior
            ventas_por_sku_anterior['ROI_Porcentaje_Anterior'] = (
                ventas_por_sku_anterior['Ingreso real'] / ventas_por_sku_anterior['Costo de venta'] * 100
            ).fillna(0)

            # Convertir a diccionario para fÃ¡cil bÃºsqueda
            skus_anteriores = {}
            for _, row in ventas_por_sku_anterior.iterrows():
                skus_anteriores[row['sku']] = {
                    'ventas_reales_anterior': float(row['Total']),
                    'costo_venta_anterior': float(row['Costo de venta']),
                    'gastos_directos_anterior': float(row['Gastos_directos']),
                    'ingreso_real_anterior': float(row['Ingreso real']),
                    'ingreso_real_porcentaje_anterior': float(row['Ingreso_Real_Porcentaje_Anterior']),
                    'costo_venta_porcentaje_anterior': float(row['Costo_Venta_Porcentaje_Anterior']),
                    'gastos_directos_porcentaje_anterior': float(row['Gastos_Directos_Porcentaje_Anterior']),
                    'roi_porcentaje_anterior': float(row['ROI_Porcentaje_Anterior']),
                    'num_transacciones_anterior': int(row['estado']),
                    'cantidad_anterior': int(row['cantidad']),
                    'periodo_comparacion': periodo_comparacion,
                    'dias_comparados': dias_transcurridos
                }

            # TambiÃ©n calcular variaciones por canal para cada SKU (para desglose por canal)
            ventas_por_sku_canal_anterior = ventas_periodo_anterior.groupby(['sku', 'Channel']).agg({
                'Total': 'sum',
                'Costo de venta': 'sum',
                'Gastos_directos': 'sum',
                'Ingreso real': 'sum',
                'cantidad': 'sum',
                'estado': 'count'
            }).reset_index()

            # Calcular porcentajes para el desglose por canal anterior
            ventas_por_sku_canal_anterior['Ingreso_Real_Porcentaje_Anterior'] = (
                ventas_por_sku_canal_anterior['Ingreso real'] / ventas_por_sku_canal_anterior['Total'] * 100
            ).fillna(0)

            ventas_por_sku_canal_anterior['Costo_Venta_Porcentaje_Anterior'] = (
                ventas_por_sku_canal_anterior['Costo de venta'] / ventas_por_sku_canal_anterior['Total'] * 100
            ).fillna(0)

            ventas_por_sku_canal_anterior['Gastos_Directos_Porcentaje_Anterior'] = (
                ventas_por_sku_canal_anterior['Gastos_directos'] / ventas_por_sku_canal_anterior['Total'] * 100
            ).fillna(0)

            # âœ… NUEVO: Calcular ROI porcentaje para canales del perÃ­odo anterior
            ventas_por_sku_canal_anterior['ROI_Porcentaje_Anterior'] = (
                ventas_por_sku_canal_anterior['Ingreso real'] / ventas_por_sku_canal_anterior['Costo de venta'] * 100
            ).fillna(0)

            # Agregar datos de canal al diccionario principal
            for _, row in ventas_por_sku_canal_anterior.iterrows():
                sku = row['sku']
                canal = row['Channel']

                if sku not in skus_anteriores:
                    continue

                if 'canales_anteriores' not in skus_anteriores[sku]:
                    skus_anteriores[sku]['canales_anteriores'] = {}

                skus_anteriores[sku]['canales_anteriores'][canal] = {
                    'ventas_reales_anterior': float(row['Total']),
                    'costo_venta_anterior': float(row['Costo de venta']),
                    'gastos_directos_anterior': float(row['Gastos_directos']),
                    'ingreso_real_anterior': float(row['Ingreso real']),
                    'ingreso_real_porcentaje_anterior': float(row['Ingreso_Real_Porcentaje_Anterior']),
                    'costo_venta_porcentaje_anterior': float(row['Costo_Venta_Porcentaje_Anterior']),
                    'gastos_directos_porcentaje_anterior': float(row['Gastos_Directos_Porcentaje_Anterior']),
                    'roi_porcentaje_anterior': float(row['ROI_Porcentaje_Anterior']),
                    'num_transacciones_anterior': int(row['estado']),
                    'cantidad_anterior': int(row['cantidad'])
                }

            print(f"âœ… Variaciones calculadas para {len(skus_anteriores)} SKUs con datos anteriores")
            return skus_anteriores
        else:
            print("âš ï¸ Sin datos del perÃ­odo anterior para SKUs")
            return {}

    except Exception as e:
        print(f"âŒ Error calculando variaciones temporales para SKUs: {e}")
        return {}

def generar_datos_skus_genericos_optimizado(df_mes_actual, df_completo, fecha_inicio, fecha_fin, skus_list, clasificacion, datos_ingreso_ideal=None, skus_anteriores_precalculados=None):
    """
    FunciÃ³n genÃ©rica optimizada para procesar cualquier lista de SKUs

    Args:
        df_mes_actual: DataFrame del mes actual
        df_completo: DataFrame completo (3 meses)
        fecha_inicio: Fecha inicio del perÃ­odo
        fecha_fin: Fecha fin del perÃ­odo
        skus_list: Lista de SKUs a procesar
        clasificacion: Nombre de la clasificaciÃ³n (para logs)
        datos_ingreso_ideal: Dict con datos de Silver.categorizacion_ingreso (opcional)

    Returns:
        Lista de datos procesados para los SKUs
    """
    if not skus_list:
        return []

    # Si no se pasaron datos de ingreso ideal, usar diccionario vacÃ­o
    if datos_ingreso_ideal is None:
        datos_ingreso_ideal = {}

    # âœ… OPTIMIZADO: Normalizar fechas del DataFrame principal (sin copy innecesario)
    df_ventas_naive = df_mes_actual
    if 'Fecha' in df_ventas_naive.columns:
        df_ventas_naive = df_ventas_naive.copy()  # Solo copiar si necesitamos modificar
        df_ventas_naive["Fecha"] = pd.to_datetime(df_ventas_naive["Fecha"]).dt.tz_localize(None)

    # Filtrar datos del perÃ­odo actual (excluir cancelados, filtrar por canales oficiales y solo SKUs de la lista)
    ventas_periodo = df_ventas_naive[
        (df_ventas_naive["estado"] != "Cancelado") &
        (df_ventas_naive['Channel'].isin(CANALES_CLASIFICACION)) &
        (df_ventas_naive['sku'].isin(skus_list))
    ].copy()

    if ventas_periodo.empty:
        print(f"âš ï¸  No hay datos vÃ¡lidos para SKUs {clasificacion} en el perÃ­odo seleccionado")
        return []

    print(f"âœ… Ventas de SKUs {clasificacion} en perÃ­odo: {len(ventas_periodo)} registros")
    if datos_ingreso_ideal:
        print(f"âœ… Datos de Ingreso Ideal disponibles para integraciÃ³n")

    # âœ… OPTIMIZADO: Usar campos pre-calculados de ClickHouse para montos, calcular porcentajes ponderados
    ventas_por_sku = ventas_periodo.groupby(['sku', 'descripcion']).agg({
        'Total': 'sum',                    # Ventas totales
        'Costo de venta': 'sum',          # Costo de venta (ya con IVA incluido)
        'Gastos_directos': 'sum',         # Â¡YA CALCULADO EN CLICKHOUSE!
        'Ingreso real': 'sum',            # Â¡YA CALCULADO EN CLICKHOUSE!
        'cantidad': 'sum',
        'estado': 'count'
    }).reset_index()

    # âœ… Calcular porcentajes ponderados correctamente para consistencia
    ventas_por_sku['Costo_Venta_Porcentaje'] = (
        ventas_por_sku['Costo de venta'] / ventas_por_sku['Total'] * 100
    ).fillna(0)
    ventas_por_sku['Gastos_Directos_Porcentaje'] = (
        ventas_por_sku['Gastos_directos'] / ventas_por_sku['Total'] * 100
    ).fillna(0)
    ventas_por_sku['Ingreso_Real_Porcentaje'] = (
        ventas_por_sku['Ingreso real'] / ventas_por_sku['Total'] * 100
    ).fillna(0)

    # âœ… NUEVO: Calcular ROI porcentaje para SKUs (igual metodologÃ­a que canales)
    ventas_por_sku['ROI_Porcentaje'] = (
        ventas_por_sku['Ingreso real'] / ventas_por_sku['Costo de venta'] * 100
    ).fillna(0)

    # Renombrar columnas para consistencia
    ventas_por_sku = ventas_por_sku.rename(columns={
        'sku': 'SKU',
        'descripcion': 'Descripcion',
        'Total': 'Ventas_Reales',
        'Costo de venta': 'Costo_Venta',
        'Gastos_directos': 'Gastos_Directos',
        'Ingreso real': 'Ingreso_Real',
        'cantidad': 'Cantidad_Total',
        'estado': 'Num_Transacciones'
    })

    print(f"âœ… OPTIMIZADO: Usando campos pre-calculados de ClickHouse para {clasificacion}")
    print(f"   â€¢ Gastos Directos: ya calculados")
    print(f"   â€¢ Ingreso Real: ya calculado")
    print(f"   â€¢ Porcentajes: calculados con mÃ©todo ponderado para consistencia")

    # Asegurar que Cantidad_Total sea numÃ©rica
    ventas_por_sku['Cantidad_Total'] = pd.to_numeric(ventas_por_sku['Cantidad_Total'], errors='coerce').fillna(0)

    # âœ… OPTIMIZADO: Calcular precio promedio por unidad vendida (vectorizado)
    ventas_por_sku['Ventas_Reales_Promedio'] = (ventas_por_sku['Ventas_Reales'] / ventas_por_sku['Cantidad_Total']).fillna(0)
    ventas_por_sku['Costo_Venta_Promedio'] = (ventas_por_sku['Costo_Venta'] / ventas_por_sku['Cantidad_Total']).fillna(0)
    ventas_por_sku['Gastos_Directos_Promedio'] = (ventas_por_sku['Gastos_Directos'] / ventas_por_sku['Cantidad_Total']).fillna(0)
    ventas_por_sku['Ingreso_Real_Promedio'] = (ventas_por_sku['Ingreso_Real'] / ventas_por_sku['Cantidad_Total']).fillna(0)

    # Ordenar por ventas descendente
    ventas_por_sku = ventas_por_sku.sort_values('Ventas_Reales', ascending=False)

    # âœ… OPTIMIZADO: Agrupar ventas por SKU Y CANAL usando campos pre-calculados
    ventas_por_sku_canal = ventas_periodo.groupby(['sku', 'descripcion', 'Channel']).agg({
        'Total': 'sum',                    # Ventas totales
        'Costo de venta': 'sum',          # Costo de venta (ya con IVA)
        'Gastos_directos': 'sum',         # Â¡YA CALCULADO EN CLICKHOUSE!
        'Ingreso real': 'sum',            # Â¡YA CALCULADO EN CLICKHOUSE!
        'cantidad': 'sum',
        'estado': 'count'
    }).reset_index()

    # âœ… Calcular porcentajes ponderados para canales (consistencia con totales)
    ventas_por_sku_canal['Costo_Venta_Porcentaje'] = (
        ventas_por_sku_canal['Costo de venta'] / ventas_por_sku_canal['Total'] * 100
    ).fillna(0)
    ventas_por_sku_canal['Gastos_Directos_Porcentaje'] = (
        ventas_por_sku_canal['Gastos_directos'] / ventas_por_sku_canal['Total'] * 100
    ).fillna(0)
    ventas_por_sku_canal['Ingreso_Real_Porcentaje'] = (
        ventas_por_sku_canal['Ingreso real'] / ventas_por_sku_canal['Total'] * 100
    ).fillna(0)

    # âœ… NUEVO: Calcular ROI porcentaje para desglose por canal de SKUs
    ventas_por_sku_canal['ROI_Porcentaje'] = (
        ventas_por_sku_canal['Ingreso real'] / ventas_por_sku_canal['Costo de venta'] * 100
    ).fillna(0)

    # Renombrar columnas para el desglose por canal
    ventas_por_sku_canal = ventas_por_sku_canal.rename(columns={
        'sku': 'SKU',
        'descripcion': 'Descripcion',
        'Channel': 'Canal',
        'Total': 'Ventas_Reales',
        'Costo de venta': 'Costo_Venta',
        'Gastos_directos': 'Gastos_Directos',
        'Ingreso real': 'Ingreso_Real',
        'cantidad': 'Cantidad_Total',
        'estado': 'Num_Transacciones'
    })

    print(f"âœ… OPTIMIZADO: Desglose por canal usando campos pre-calculados")

    # Asegurar que Cantidad_Total sea numÃ©rica para el desglose por canal
    ventas_por_sku_canal['Cantidad_Total'] = pd.to_numeric(ventas_por_sku_canal['Cantidad_Total'], errors='coerce').fillna(0)

    # âœ… OPTIMIZADO: Calcular precio promedio por unidad vendida para el desglose por canal (vectorizado)
    ventas_por_sku_canal['Ventas_Reales_Promedio'] = (ventas_por_sku_canal['Ventas_Reales'] / ventas_por_sku_canal['Cantidad_Total']).fillna(0)
    ventas_por_sku_canal['Costo_Venta_Promedio'] = (ventas_por_sku_canal['Costo_Venta'] / ventas_por_sku_canal['Cantidad_Total']).fillna(0)
    ventas_por_sku_canal['Gastos_Directos_Promedio'] = (ventas_por_sku_canal['Gastos_Directos'] / ventas_por_sku_canal['Cantidad_Total']).fillna(0)
    ventas_por_sku_canal['Ingreso_Real_Promedio'] = (ventas_por_sku_canal['Ingreso_Real'] / ventas_por_sku_canal['Cantidad_Total']).fillna(0)

    # âœ… OPTIMIZACIÃ“N: Usar variaciones pre-calculadas si estÃ¡n disponibles
    if skus_anteriores_precalculados is not None:
        print(f"âœ… OPTIMIZACIÃ“N: Usando variaciones pre-calculadas para {clasificacion}")
        skus_anteriores = skus_anteriores_precalculados
    else:
        # Fallback: calcular si no se pasaron (para compatibilidad con funciones antiguas)
        print(f"âš ï¸ FALLBACK: Calculando variaciones para {clasificacion} (no se pasaron pre-calculadas)")
        skus_list_para_historia = skus_list.copy()
        for sku in skus_list:
            if sku in PRODUCTOS_UNIFICADOS:
                gemelos = PRODUCTOS_UNIFICADOS[sku]
                skus_list_para_historia.extend(gemelos)
                print(f"   ðŸ”— Buscando datos histÃ³ricos del producto unificado {sku} y sus gemelos: {gemelos}")
        skus_list_para_historia = list(set(skus_list_para_historia))
        skus_anteriores = calcular_variaciones_temporales_skus(df_completo, skus_list_para_historia)

    # Convertir a lista de diccionarios para el template
    skus_data = []
    for _, row in ventas_por_sku.iterrows():
        sku_actual = row['SKU']

        # âœ… NUEVO: Obtener datos de variaciones temporales para este SKU
        sku_anterior = skus_anteriores.get(sku_actual, {})
        sku_variacion_ventas_pct = 0.0
        sku_variacion_ingreso_pct = 0.0  # VariaciÃ³n nominal del monto de ingreso real
        sku_variacion_ingreso_porcentaje_pct = 0.0  # VariaciÃ³n de puntos porcentuales del % ingreso
        sku_variacion_costo_pct = 0.0
        sku_variacion_gastos_pct = 0.0
        sku_variacion_roi_pct = 0.0
        sku_periodo_comparacion = 'Sin comparaciÃ³n'
        sku_dias_comparados = 0

        if sku_anterior:
            # Calcular variaciÃ³n de ventas del SKU (porcentaje de cambio relativo)
            if sku_anterior.get('ventas_reales_anterior', 0) > 0:
                sku_variacion_ventas_pct = ((row['Ventas_Reales'] - sku_anterior['ventas_reales_anterior']) /
                                          sku_anterior['ventas_reales_anterior'] * 100)

            # Calcular variaciÃ³n NOMINAL de ingreso real del SKU (comparando montos)
            ingreso_anterior = sku_anterior.get('ingreso_real_anterior', 0)
            if ingreso_anterior != 0:
                sku_variacion_ingreso_pct = ((row['Ingreso_Real'] - ingreso_anterior) /
                                            abs(ingreso_anterior) * 100)
                print(f"ðŸ” SKU {sku_actual}: Ingreso Real ${row['Ingreso_Real']:,.0f} vs ${ingreso_anterior:,.0f} = {sku_variacion_ingreso_pct:+.1f}%")
            else:
                sku_variacion_ingreso_pct = 0.0
                print(f"âš ï¸ SKU {sku_actual}: Sin ingreso anterior (ingreso_real_anterior={ingreso_anterior})")

            # Calcular variaciÃ³n de PUNTOS PORCENTUALES del % ingreso real del SKU
            sku_variacion_ingreso_porcentaje_pct = (row['Ingreso_Real_Porcentaje'] -
                                                    sku_anterior.get('ingreso_real_porcentaje_anterior', 0))

            # Calcular variaciÃ³n de costo de venta del SKU (puntos porcentuales)
            sku_variacion_costo_pct = (row['Costo_Venta_Porcentaje'] -
                                     sku_anterior.get('costo_venta_porcentaje_anterior', 0))

            # Calcular variaciÃ³n de gastos directos del SKU (puntos porcentuales)
            sku_variacion_gastos_pct = (row['Gastos_Directos_Porcentaje'] -
                                      sku_anterior.get('gastos_directos_porcentaje_anterior', 0))

            # âœ… NUEVO: Calcular variaciÃ³n de ROI del SKU (puntos porcentuales)
            sku_variacion_roi_pct = (row['ROI_Porcentaje'] -
                                    sku_anterior.get('roi_porcentaje_anterior', 0))

            sku_periodo_comparacion = sku_anterior.get('periodo_comparacion', 'Sin comparaciÃ³n')
            sku_dias_comparados = sku_anterior.get('dias_comparados', 0)

        # Obtener desglose por canal para este SKU
        canales_sku = ventas_por_sku_canal[ventas_por_sku_canal['SKU'] == sku_actual]
        desglose_canales = []

        for _, canal_row in canales_sku.iterrows():
            canal_actual = canal_row['Canal']

            # âœ… NUEVO: Buscar datos de variaciones del canal anterior para este SKU especÃ­fico
            canal_anterior = None
            canal_variacion_ventas_pct = 0.0
            canal_variacion_ingreso_pct = 0.0  # VariaciÃ³n nominal del monto de ingreso real
            canal_variacion_ingreso_porcentaje_pct = 0.0  # VariaciÃ³n de puntos porcentuales del % ingreso
            canal_variacion_costo_pct = 0.0
            canal_variacion_gastos_pct = 0.0
            canal_variacion_roi_pct = 0.0

            if sku_actual in skus_anteriores and 'canales_anteriores' in skus_anteriores[sku_actual]:
                if canal_actual in skus_anteriores[sku_actual]['canales_anteriores']:
                    canal_anterior = skus_anteriores[sku_actual]['canales_anteriores'][canal_actual]

                    # Calcular variaciÃ³n de ventas del canal (porcentaje de cambio relativo)
                    if canal_anterior['ventas_reales_anterior'] > 0:
                        canal_variacion_ventas_pct = ((canal_row['Ventas_Reales'] - canal_anterior['ventas_reales_anterior']) /
                                                    canal_anterior['ventas_reales_anterior'] * 100)

                    # Calcular variaciÃ³n NOMINAL de ingreso real del canal (comparando montos)
                    if canal_anterior.get('ingreso_real_anterior', 0) != 0:
                        canal_variacion_ingreso_pct = ((canal_row['Ingreso_Real'] - canal_anterior['ingreso_real_anterior']) /
                                                      abs(canal_anterior['ingreso_real_anterior']) * 100)
                    else:
                        canal_variacion_ingreso_pct = 0.0

                    # Calcular variaciÃ³n de PUNTOS PORCENTUALES del % ingreso real del canal
                    canal_variacion_ingreso_porcentaje_pct = (canal_row['Ingreso_Real_Porcentaje'] -
                                                             canal_anterior['ingreso_real_porcentaje_anterior'])

                    # Calcular variaciÃ³n de costo de venta del canal (puntos porcentuales)
                    canal_variacion_costo_pct = (canal_row['Costo_Venta_Porcentaje'] -
                                                canal_anterior['costo_venta_porcentaje_anterior'])

                    # Calcular variaciÃ³n de gastos directos del canal (puntos porcentuales)
                    canal_variacion_gastos_pct = (canal_row['Gastos_Directos_Porcentaje'] -
                                                 canal_anterior['gastos_directos_porcentaje_anterior'])

                    # âœ… NUEVO: Calcular variaciÃ³n de ROI del canal (puntos porcentuales)
                    canal_variacion_roi_pct = (canal_row['ROI_Porcentaje'] -
                                              canal_anterior.get('roi_porcentaje_anterior', 0))

            # âœ… NUEVO: Buscar datos de Ingreso Ideal para este SKU + Canal
            ingreso_ideal_info = {}
            tiene_ingreso_ideal = False
            gap_ingreso_pp = 0.0
            gap_precio = 0.0
            cumple_ideal = None
            potencial_mensual = 0.0

            if sku_actual in datos_ingreso_ideal and canal_actual in datos_ingreso_ideal[sku_actual]:
                ingreso_ideal_info = datos_ingreso_ideal[sku_actual][canal_actual]
                tiene_ingreso_ideal = True

                # Calcular GAP entre Ingreso Real actual e ideal
                gap_ingreso_pp = canal_row['Ingreso_Real_Porcentaje'] - ingreso_ideal_info['ir_final']

                # Calcular GAP de precio
                gap_precio = canal_row['Ventas_Reales_Promedio'] - ingreso_ideal_info['precio_ideal']

                # Determinar si cumple el ideal
                cumple_ideal = gap_ingreso_pp >= 0

                # Calcular potencial mensual (diferencia en $ si alcanzara el ideal)
                if gap_ingreso_pp < 0:
                    # Potencial = Ventas Ã— (IR_Ideal% - IR_Actual%) / 100
                    potencial_mensual = canal_row['Ventas_Reales'] * abs(gap_ingreso_pp) / 100

            canal_data = {
                'canal': canal_actual,
                'ventas_reales': float(canal_row['Ventas_Reales']),
                'costo_venta': float(canal_row['Costo_Venta']),
                'gastos_directos': float(canal_row['Gastos_Directos']),
                'ingreso_real': float(canal_row['Ingreso_Real']),
                'costo_venta_porcentaje': float(canal_row['Costo_Venta_Porcentaje']),
                'gastos_directos_porcentaje': float(canal_row['Gastos_Directos_Porcentaje']),
                'ingreso_real_porcentaje': float(canal_row['Ingreso_Real_Porcentaje']),
                'roi_porcentaje': float(canal_row['ROI_Porcentaje']),
                'num_transacciones': int(canal_row['Num_Transacciones']),
                'ventas_reales_promedio': float(canal_row['Ventas_Reales_Promedio']),
                'costo_venta_promedio': float(canal_row['Costo_Venta_Promedio']),
                'gastos_directos_promedio': float(canal_row['Gastos_Directos_Promedio']),
                'ingreso_real_promedio': float(canal_row['Ingreso_Real_Promedio']),
                # âœ… NUEVO: Campos de variaciones temporales para canal
                'ventas_reales_anterior': canal_anterior['ventas_reales_anterior'] if canal_anterior else 0.0,
                'ingreso_real_porcentaje_anterior': canal_anterior['ingreso_real_porcentaje_anterior'] if canal_anterior else 0.0,
                'costo_venta_porcentaje_anterior': canal_anterior['costo_venta_porcentaje_anterior'] if canal_anterior else 0.0,
                'gastos_directos_porcentaje_anterior': canal_anterior['gastos_directos_porcentaje_anterior'] if canal_anterior else 0.0,
                'roi_porcentaje_anterior': canal_anterior.get('roi_porcentaje_anterior', 0.0) if canal_anterior else 0.0,
                'variacion_ventas_pct': float(canal_variacion_ventas_pct),
                'variacion_ingreso_pct': float(canal_variacion_ingreso_pct),  # VariaciÃ³n nominal del monto
                'variacion_ingreso_porcentaje_pct': float(canal_variacion_ingreso_porcentaje_pct),  # VariaciÃ³n pp del %
                'variacion_costo_venta_pct': float(canal_variacion_costo_pct),
                'variacion_gastos_directos_pct': float(canal_variacion_gastos_pct),
                'variacion_roi_pct': float(canal_variacion_roi_pct),
                'periodo_comparacion': sku_periodo_comparacion,
                'dias_comparados': sku_dias_comparados,

                # âœ… NUEVO: Campos de Ingreso Ideal
                'tiene_ingreso_ideal': tiene_ingreso_ideal,
                'ir_base': ingreso_ideal_info.get('ir_base', 0.0),
                'factor_competencia': ingreso_ideal_info.get('competencia', 0.0),
                'factor_diferenciador': ingreso_ideal_info.get('diferenciador', 0.0),
                'factor_calidad': ingreso_ideal_info.get('calidad', 0.0),
                'factor_percepcion': ingreso_ideal_info.get('percepcion', 0.0),
                'factor_funcionalidad': ingreso_ideal_info.get('funcionalidad', 0.0),
                'ir_ideal': ingreso_ideal_info.get('ir_final', 0.0),
                'precio_ideal': ingreso_ideal_info.get('precio_ideal', 0.0),
                'ir_por_unidad_ideal': ingreso_ideal_info.get('ir_por_unidad', 0.0),
                'gap_ingreso_pp': float(gap_ingreso_pp),
                'gap_precio': float(gap_precio),
                'cumple_ideal': cumple_ideal,
                'potencial_mensual': float(potencial_mensual)
            }
            desglose_canales.append(canal_data)

        # Ordenar canales por ventas descendente
        desglose_canales.sort(key=lambda x: x['ventas_reales'], reverse=True)

        # Agregar desglose temporal usando datos completos
        desglose_temporal = calcular_desglose_temporal_sku(df_completo, sku_actual)

        sku_item = {
            'sku': sku_actual,
            'descripcion': row['Descripcion'],
            'ventas_reales': float(row['Ventas_Reales']),
            'costo_venta': float(row['Costo_Venta']),
            'gastos_directos': float(row['Gastos_Directos']),
            'ingreso_real': float(row['Ingreso_Real']),
            'costo_venta_porcentaje': float(row['Costo_Venta_Porcentaje']),
            'gastos_directos_porcentaje': float(row['Gastos_Directos_Porcentaje']),
            'ingreso_real_porcentaje': float(row['Ingreso_Real_Porcentaje']),
            'roi_porcentaje': float(row['ROI_Porcentaje']),
            'num_transacciones': int(row['Num_Transacciones']),
            'ventas_reales_promedio': float(row['Ventas_Reales_Promedio']),
            'costo_venta_promedio': float(row['Costo_Venta_Promedio']),
            'gastos_directos_promedio': float(row['Gastos_Directos_Promedio']),
            'ingreso_real_promedio': float(row['Ingreso_Real_Promedio']),
            'desglose_canales': desglose_canales,
            'desglose_meses': desglose_temporal,
            # âœ… NUEVO: Campos de variaciones temporales para SKU principal
            'ventas_reales_anterior': sku_anterior.get('ventas_reales_anterior', 0.0),
            'costo_venta_anterior': sku_anterior.get('costo_venta_anterior', 0.0),
            'gastos_directos_anterior': sku_anterior.get('gastos_directos_anterior', 0.0),
            'ingreso_real_anterior': sku_anterior.get('ingreso_real_anterior', 0.0),
            'ingreso_real_porcentaje_anterior': sku_anterior.get('ingreso_real_porcentaje_anterior', 0.0),
            'costo_venta_porcentaje_anterior': sku_anterior.get('costo_venta_porcentaje_anterior', 0.0),
            'gastos_directos_porcentaje_anterior': sku_anterior.get('gastos_directos_porcentaje_anterior', 0.0),
            'roi_porcentaje_anterior': sku_anterior.get('roi_porcentaje_anterior', 0.0),
            'variacion_ventas_pct': float(sku_variacion_ventas_pct),
            'variacion_ingreso_pct': float(sku_variacion_ingreso_pct),  # VariaciÃ³n nominal del monto
            'variacion_ingreso_porcentaje_pct': float(sku_variacion_ingreso_porcentaje_pct),  # VariaciÃ³n pp del %
            'variacion_costo_venta_pct': float(sku_variacion_costo_pct),
            'variacion_gastos_directos_pct': float(sku_variacion_gastos_pct),
            'variacion_roi_pct': float(sku_variacion_roi_pct),
            'periodo_comparacion': sku_periodo_comparacion,
            'dias_comparados': sku_dias_comparados
        }

        # ðŸ” DEBUG: Imprimir los valores de variaciÃ³n antes de agregar al template
        if clasificacion in ['Prometedores', 'Potenciales']:
            print(f"ðŸ” DEBUG {clasificacion} - SKU {sku_actual}:")
            print(f"   variacion_ingreso_pct = {sku_item['variacion_ingreso_pct']}")
            print(f"   variacion_ingreso_porcentaje_pct = {sku_item['variacion_ingreso_porcentaje_pct']}")
            print(f"   ingreso_real = ${sku_item['ingreso_real']:,.0f}")
            print(f"   ingreso_real_anterior = ${sku_item['ingreso_real_anterior']:,.0f}")

        skus_data.append(sku_item)

    # CALCULAR FILA DE TOTALES para la clasificaciÃ³n
    if skus_data:
        print(f"ðŸ“Š Calculando totales para SKUs {clasificacion}...")

        # Sumar todos los valores
        total_ventas_reales = sum(sku['ventas_reales'] for sku in skus_data)
        total_costo_venta = sum(sku['costo_venta'] for sku in skus_data)
        total_gastos_directos = sum(sku['gastos_directos'] for sku in skus_data)
        total_ingreso_real = sum(sku['ingreso_real'] for sku in skus_data)
        total_num_transacciones = sum(sku['num_transacciones'] for sku in skus_data)

        # Calcular promedios por unidad (suma total dividida por cantidad total)
        cantidad_total_todos_skus = ventas_por_sku['Cantidad_Total'].sum()

        total_ventas_reales_promedio = total_ventas_reales / cantidad_total_todos_skus if cantidad_total_todos_skus > 0 else 0
        total_costo_venta_promedio = total_costo_venta / cantidad_total_todos_skus if cantidad_total_todos_skus > 0 else 0
        total_gastos_directos_promedio = total_gastos_directos / cantidad_total_todos_skus if cantidad_total_todos_skus > 0 else 0
        total_ingreso_real_promedio = total_ingreso_real / cantidad_total_todos_skus if cantidad_total_todos_skus > 0 else 0

        # Calcular porcentajes ponderados
        total_costo_venta_porcentaje = (total_costo_venta / total_ventas_reales * 100) if total_ventas_reales > 0 else 0
        total_gastos_directos_porcentaje = (total_gastos_directos / total_ventas_reales * 100) if total_ventas_reales > 0 else 0
        total_ingreso_real_porcentaje = (total_ingreso_real / total_ventas_reales * 100) if total_ventas_reales > 0 else 0

        # âœ… NUEVO: Calcular ROI total (igual metodologÃ­a que SKUs individuales)
        total_roi_porcentaje = (total_ingreso_real / total_costo_venta * 100) if total_costo_venta > 0 else 0

        # Crear item de totales
        totales_item = {
            'sku': f'TOTAL-{clasificacion.upper()}',
            'descripcion': f'TOTAL - {clasificacion}',
            'ventas_reales': total_ventas_reales,
            'costo_venta': total_costo_venta,
            'gastos_directos': total_gastos_directos,
            'ingreso_real': total_ingreso_real,
            'costo_venta_porcentaje': total_costo_venta_porcentaje,
            'gastos_directos_porcentaje': total_gastos_directos_porcentaje,
            'ingreso_real_porcentaje': total_ingreso_real_porcentaje,
            'roi_porcentaje': total_roi_porcentaje,
            'num_transacciones': total_num_transacciones,
            'ventas_reales_promedio': total_ventas_reales_promedio,
            'costo_venta_promedio': total_costo_venta_promedio,
            'gastos_directos_promedio': total_gastos_directos_promedio,
            'ingreso_real_promedio': total_ingreso_real_promedio,
            'desglose_canales': [],  # Los totales no tienen desglose por canal
            'desglose_meses': [],    # Los totales no tienen desglose temporal
            'es_fila_total': True    # Flag para identificar en el template
        }

        # Agregar totales al final de la lista
        skus_data.append(totales_item)

        print(f"âœ… Fila de totales agregada para SKUs {clasificacion}")
        print(f"ðŸ“ˆ Total Ventas: ${total_ventas_reales:,.0f} | Ingreso Real: ${total_ingreso_real:,.0f} ({total_ingreso_real_porcentaje:.1f}%)")

    print(f"âœ… Datos de SKUs {clasificacion} generados exitosamente: {len(skus_data)} SKUs (incluyendo totales)")
    return skus_data

def generar_datos_skus_estrella_rentabilidad(df_mes_actual, df_completo, fecha_inicio, fecha_fin):
    """
    SOLO PARA ANÃLISIS DE RENTABILIDAD
    Genera datos de SKUs Estrella con mÃ©tricas del mes actual + desglose temporal de 3 meses
    """
    # Usar la funciÃ³n original pero con datos del mes actual para mÃ©tricas principales
    skus_data = generar_datos_skus_estrella(df_mes_actual, fecha_inicio, fecha_fin)

    # Ahora agregar el desglose temporal usando datos completos
    for sku_item in skus_data:
        sku_actual = sku_item['sku']

        # Calcular desglose temporal usando datos completos (3 meses)
        desglose_temporal = calcular_desglose_temporal_sku(df_completo, sku_actual)
        sku_item['desglose_meses'] = desglose_temporal

    return skus_data

def generar_datos_skus_prometedores_rentabilidad(df_mes_actual, df_completo, fecha_inicio, fecha_fin):
    """
    SOLO PARA ANÃLISIS DE RENTABILIDAD
    Genera datos de SKUs Prometedores con mÃ©tricas del mes actual + desglose temporal de 3 meses
    """
    # Usar la funciÃ³n original pero con datos del mes actual para mÃ©tricas principales
    skus_data = generar_datos_skus_prometedores(df_mes_actual, fecha_inicio, fecha_fin)

    # Ahora agregar el desglose temporal usando datos completos
    for sku_item in skus_data:
        sku_actual = sku_item['sku']

        # Calcular desglose temporal usando datos completos (3 meses)
        desglose_temporal = calcular_desglose_temporal_sku(df_completo, sku_actual)
        sku_item['desglose_meses'] = desglose_temporal

    return skus_data

def generar_datos_skus_potenciales_rentabilidad(df_mes_actual, df_completo, fecha_inicio, fecha_fin):
    """
    SOLO PARA ANÃLISIS DE RENTABILIDAD
    Genera datos de SKUs Potenciales con mÃ©tricas del mes actual + desglose temporal de 3 meses
    """
    # Usar la funciÃ³n original pero con datos del mes actual para mÃ©tricas principales
    skus_data = generar_datos_skus_potenciales(df_mes_actual, fecha_inicio, fecha_fin)

    # Ahora agregar el desglose temporal usando datos completos
    for sku_item in skus_data:
        sku_actual = sku_item['sku']

        # Calcular desglose temporal usando datos completos (3 meses)
        desglose_temporal = calcular_desglose_temporal_sku(df_completo, sku_actual)
        sku_item['desglose_meses'] = desglose_temporal

    return skus_data

def calcular_desglose_temporal_sku(df_completo, sku):
    """
    Calcula el desglose temporal de los Ãºltimos 3 meses para un SKU especÃ­fico
    """
    from datetime import datetime
    from dateutil.relativedelta import relativedelta
    import calendar

    if df_completo.empty:
        return []

    # Normalizar fechas
    df_temporal = df_completo.copy()
    if 'Fecha' in df_temporal.columns:
        df_temporal["Fecha"] = pd.to_datetime(df_temporal["Fecha"]).dt.tz_localize(None)

    hoy = datetime.now()
    dia_actual = hoy.day

    # Generar los 3 meses a analizar
    meses_analizar = []
    for i in range(3):
        fecha_mes = hoy.replace(day=1) - relativedelta(months=i)
        meses_analizar.append(fecha_mes)

    desglose_meses = []
    for fecha_mes in meses_analizar:
        # Determinar el Ãºltimo dÃ­a a incluir
        ultimo_dia = min(dia_actual, calendar.monthrange(fecha_mes.year, fecha_mes.month)[1])
        fecha_inicio_mes = fecha_mes
        fecha_fin_mes = fecha_mes.replace(day=ultimo_dia)

        # Filtrar datos del SKU para este mes especÃ­fico
        ventas_sku_mes = df_temporal[
            (df_temporal['sku'] == sku) &
            (df_temporal["estado"] != "Cancelado") &
            (df_temporal['Channel'].isin(CANALES_CLASIFICACION)) &
            (pd.to_datetime(df_temporal['Fecha']).dt.date >= fecha_inicio_mes.date()) &
            (pd.to_datetime(df_temporal['Fecha']).dt.date <= fecha_fin_mes.date())
        ]

        if not ventas_sku_mes.empty:
            # Calcular mÃ©tricas para el mes
            ventas_reales_mes = ventas_sku_mes['Total'].sum()
            costo_venta_mes = ventas_sku_mes['Costo de venta'].sum()  # * 1.16 - IVA ya incluido en los datos base
            comision_venta_mes = ventas_sku_mes['Comision por venta'].sum()
            gastos_destino_mes = ventas_sku_mes['gastos_destino'].sum()  # * 1.16 - IVA ya incluido en los datos base
            ultima_milla_mes = ventas_sku_mes['Ultima_milla'].sum()
            num_transacciones_mes = len(ventas_sku_mes)

            gastos_directos_mes = comision_venta_mes + gastos_destino_mes + ultima_milla_mes
            ingreso_real_mes = ventas_reales_mes - costo_venta_mes - gastos_directos_mes

            # Calcular porcentajes
            costo_venta_porcentaje_mes = (costo_venta_mes / ventas_reales_mes * 100) if ventas_reales_mes > 0 else 0
            gastos_directos_porcentaje_mes = (gastos_directos_mes / ventas_reales_mes * 100) if ventas_reales_mes > 0 else 0
            ingreso_real_porcentaje_mes = (ingreso_real_mes / ventas_reales_mes * 100) if ventas_reales_mes > 0 else 0

            # Calcular promedios
            ventas_reales_promedio_mes = ventas_reales_mes / num_transacciones_mes if num_transacciones_mes > 0 else 0
            costo_venta_promedio_mes = costo_venta_mes / num_transacciones_mes if num_transacciones_mes > 0 else 0
            gastos_directos_promedio_mes = gastos_directos_mes / num_transacciones_mes if num_transacciones_mes > 0 else 0
            ingreso_real_promedio_mes = ingreso_real_mes / num_transacciones_mes if num_transacciones_mes > 0 else 0

            # Crear desglose por canal para este mes
            desglose_canales_mes = []
            if not ventas_sku_mes.empty:
                ventas_por_canal_mes = ventas_sku_mes.groupby('Channel').agg({
                    'Total': 'sum',
                    'Costo de venta': 'sum',
                    'Comision por venta': 'sum',
                    'gastos_destino': 'sum',
                    'Ultima_milla': 'sum',
                    'estado': 'count'
                }).reset_index()

                ventas_por_canal_mes.columns = ['Canal', 'Ventas_Reales', 'Costo_Venta', 'Comision_Venta', 'Gastos_Destino', 'Ultima_Milla', 'Num_Transacciones']

                # Aplicar IVA - COMENTADO: IVA ya incluido en los datos base
                # ventas_por_canal_mes['Costo_Venta'] = ventas_por_canal_mes['Costo_Venta'] * 1.16
                # ventas_por_canal_mes['Gastos_Destino'] = ventas_por_canal_mes['Gastos_Destino'] * 1.16

                for _, canal_row in ventas_por_canal_mes.iterrows():
                    gastos_directos_canal = canal_row['Comision_Venta'] + canal_row['Gastos_Destino'] + canal_row['Ultima_Milla']
                    ingreso_real_canal = canal_row['Ventas_Reales'] - canal_row['Costo_Venta'] - gastos_directos_canal

                    # âœ… NUEVO: Calcular ROI para canal por mes
                    roi_porcentaje_canal = (ingreso_real_canal / canal_row['Costo_Venta'] * 100) if canal_row['Costo_Venta'] > 0 else 0

                    canal_data = {
                        'canal': canal_row['Canal'],
                        'ventas_reales': float(canal_row['Ventas_Reales']),
                        'costo_venta': float(canal_row['Costo_Venta']),
                        'gastos_directos': float(gastos_directos_canal),
                        'ingreso_real': float(ingreso_real_canal),
                        'costo_venta_porcentaje': float((canal_row['Costo_Venta'] / canal_row['Ventas_Reales'] * 100) if canal_row['Ventas_Reales'] > 0 else 0),
                        'gastos_directos_porcentaje': float((gastos_directos_canal / canal_row['Ventas_Reales'] * 100) if canal_row['Ventas_Reales'] > 0 else 0),
                        'ingreso_real_porcentaje': float((ingreso_real_canal / canal_row['Ventas_Reales'] * 100) if canal_row['Ventas_Reales'] > 0 else 0),
                        'roi_porcentaje': float(roi_porcentaje_canal),
                        'num_transacciones': int(canal_row['Num_Transacciones']),
                        'ventas_reales_promedio': float(canal_row['Ventas_Reales'] / canal_row['Num_Transacciones'] if canal_row['Num_Transacciones'] > 0 else 0),
                        'costo_venta_promedio': float(canal_row['Costo_Venta'] / canal_row['Num_Transacciones'] if canal_row['Num_Transacciones'] > 0 else 0),
                        'gastos_directos_promedio': float(gastos_directos_canal / canal_row['Num_Transacciones'] if canal_row['Num_Transacciones'] > 0 else 0),
                        'ingreso_real_promedio': float(ingreso_real_canal / canal_row['Num_Transacciones'] if canal_row['Num_Transacciones'] > 0 else 0)
                    }
                    desglose_canales_mes.append(canal_data)
                # Ordenar canales por ventas descendente dentro del mes
                desglose_canales_mes.sort(key=lambda x: x['ventas_reales'], reverse=True)

            # âœ… NUEVO: Calcular ROI porcentaje para el mes
            roi_porcentaje_mes = (ingreso_real_mes / costo_venta_mes * 100) if costo_venta_mes > 0 else 0

            mes_data = {
                'mes': fecha_mes.month,
                'aÃ±o': fecha_mes.year,
                'periodo': f"1-{ultimo_dia} {fecha_mes.strftime('%b %Y')}",
                'ventas_reales': float(ventas_reales_mes),
                'costo_venta': float(costo_venta_mes),
                'gastos_directos': float(gastos_directos_mes),
                'ingreso_real': float(ingreso_real_mes),
                'costo_venta_porcentaje': float(costo_venta_porcentaje_mes),
                'gastos_directos_porcentaje': float(gastos_directos_porcentaje_mes),
                'ingreso_real_porcentaje': float(ingreso_real_porcentaje_mes),
                'roi_porcentaje': float(roi_porcentaje_mes),
                'num_transacciones': int(num_transacciones_mes),
                'ventas_reales_promedio': float(ventas_reales_promedio_mes),
                'costo_venta_promedio': float(costo_venta_promedio_mes),
                'gastos_directos_promedio': float(gastos_directos_promedio_mes),
                'ingreso_real_promedio': float(ingreso_real_promedio_mes),
                'desglose_canales': desglose_canales_mes
            }
            desglose_meses.append(mes_data)

    return desglose_meses

# FUNCIONES EXISTENTES DE ANÃLISIS
def resumen_periodo(df_periodo, df_comparado, granularidad):
    resumen = []
    
    # Ventas brutas
    total_main = df_periodo["Total"].sum()
    total_compare = df_comparado["Total"].sum()
    delta = total_main - total_compare
    pct = (delta / total_compare * 100) if total_compare else 0
    resumen.append({
        "label": "Ventas brutas", 
        "valor": f"${total_main:,.0f}", 
        "diferencia": f"{'â–²' if pct >= 0 else 'â–¼'} {abs(pct):.1f} %", 
        "delta": pct
    })
    
    # Cancelaciones
    canc_main = df_periodo[df_periodo["estado"] == "Cancelado"]["Total"].sum()
    canc_compare = df_comparado[df_comparado["estado"] == "Cancelado"]["Total"].sum()
    delta = canc_main - canc_compare
    pct = (delta / canc_compare * 100) if canc_compare else 0
    resumen.append({
        "label": "Cancelaciones", 
        "valor": f"${canc_main:,.0f}", 
        "diferencia": f"{'â–²' if pct >= 0 else 'â–¼'} {abs(pct):.1f} %", 
        "delta": -pct 
    })
    
    # Ingreso Neto
    net_main = df_periodo[df_periodo["estado"] != "Cancelado"]["Total"].sum()
    net_compare = df_comparado[df_comparado["estado"] != "Cancelado"]["Total"].sum()
    delta = net_main - net_compare
    pct = (delta / net_compare * 100) if net_compare else 0
    resumen.append({
        "label": "Ingreso Neto", 
        "valor": f"${net_main:,.0f}", 
        "diferencia": f"{'â–²' if pct >= 0 else 'â–¼'} {abs(pct):.1f} %", 
        "delta": pct
    })
    
    return resumen

def crear_gauge_costo_config(porcentaje_actual, canal="Canal"):
    """
    Crear configuraciÃ³n JSON de Plotly para gauge de costo de venta
    ConfiguraciÃ³n especÃ­fica para Metas de Costo con zona amarilla MÃXIMAMENTE CENTRADA:
    - Rango visual: 45%-57% (12 puntos totales) para mÃ¡xima expansiÃ³n de zona objetivo
    - Verde (45%-48%): 3 puntos = 25% del espacio visual
    - Amarillo (48%-54%): 6 puntos = 50% del espacio visual - DOMINANCIA TOTAL
    - Rojo (54%-57%): 3 puntos = 25% del espacio visual
    - Zona amarilla ocupa LA MITAD del grÃ¡fico con mÃ¡xima granularidad y centrado perfecto
    """
    try:
        # Validar entrada
        if porcentaje_actual is None or porcentaje_actual < 0:
            print(f"WARN: porcentaje_actual invÃ¡lido: {porcentaje_actual}, usando 50 por defecto")
            porcentaje_actual = 50.0
        gauge_config = {
            'data': [
                # Indicador principal
                {
                    'type': 'indicator',
                    'mode': 'gauge+number',
                    'value': porcentaje_actual,
                    'title': {'text': ""},  # Sin tÃ­tulo
                    'number': {
                        'font': {'size': 28, 'color': '#1a1a1a', 'family': 'Inter, -apple-system, sans-serif', 'weight': 700}, 
                        'suffix': "%",
                        'valueformat': '.1f'
                    },
                    'domain': {'x': [0, 1], 'y': [0, 1]},
                    'gauge': {
                        'axis': {
                            'range': [45, 57], 
                            'tickmode': 'array',
                            'tickvals': [45, 57],  # Solo extremos
                            'ticktext': ['45', '57'],  # Solo etiquetas extremas
                            'tickwidth': 2, 
                            'tickcolor': "#666", 
                            'ticklen': 10,
                            'tickfont': {'size': 9, 'color': '#4a5568', 'family': 'Inter, -apple-system, sans-serif'}
                        },
                        'bar': {'color': "transparent", 'thickness': 0},  # Sin lÃ­nea de progreso
                        'bgcolor': "rgba(248, 250, 252, 0.9)",
                        'borderwidth': 0,
                        'steps': [
                            # Verde intenso (45%-47%): Excelente (costo muy bajo)
                            {'range': [45, 46], 'color': "#20c997"},    # Verde teal puro
                            {'range': [46, 47], 'color': "#24b386"},    # TransiciÃ³n tealâ†’verde
                            
                            # Verde claro (47%-48%): Muy bueno (costo bajo)
                            {'range': [47, 48], 'color': "#28a745"},    # Verde Ã©xito puro
                            
                            # DEGRADADO AMARILLO (48%-54%): De dÃ©bil a fuerte hacia el rojo
                            {'range': [48, 48.5], 'color': "#fff3cd"},  # Amarillo muy claro (cerca del verde)
                            {'range': [48.5, 49], 'color': "#ffecb3"},  # Amarillo suave
                            {'range': [49, 49.5], 'color': "#ffe082"},  # Amarillo claro
                            {'range': [49.5, 50], 'color': "#ffd54f"},  # Amarillo medio-claro
                            {'range': [50, 50.5], 'color': "#ffc107"},  # Amarillo estÃ¡ndar (centro)
                            {'range': [50.5, 51], 'color': "#ffb300"},  # Amarillo medio-fuerte
                            {'range': [51, 51.5], 'color': "#ffa000"},  # Amarillo fuerte
                            {'range': [51.5, 52], 'color': "#ff9800"},  # Amarillo-naranja suave
                            {'range': [52, 52.5], 'color': "#ff8f00"},  # Amarillo-naranja medio
                            {'range': [52.5, 53], 'color': "#ff8a65"},  # Amarillo-naranja fuerte
                            {'range': [53, 53.5], 'color': "#ff7043"},  # Casi naranja
                            {'range': [53.5, 54], 'color': "#ff6f00"},  # Naranja-amarillo (cerca del rojo)
                            
                            # Rojo (54%-57%): Alto Riesgo - despuÃ©s del rango objetivo
                            {'range': [54, 55.5], 'color': "#dc3545"},  # Rojo puro
                            {'range': [55.5, 57], 'color': "#c82333"}   # Rojo intenso final
                        ],
                        'threshold': {
                            'line': {'color': "#1f2937", 'width': 6},  # Aguja principal mÃ¡s gruesa y elegante
                            'thickness': 0.85,
                            'value': porcentaje_actual
                        },
                        'shape': "angular"
                    }
                },
                # Mini aguja marcadora en 48% 
                {
                    'type': 'indicator',
                    'mode': 'gauge',
                    'value': 48,  # Valor fijo en 48%
                    'domain': {'x': [0, 1], 'y': [0, 1]},
                    'gauge': {
                        'axis': {'range': [45, 57], 'visible': False},  # Mismo rango, eje invisible
                        'bar': {'color': "transparent", 'thickness': 0},
                        'bgcolor': "transparent",
                        'borderwidth': 0,
                        'threshold': {
                            'line': {'color': "#ffc107", 'width': 4},  # Aguja amarilla mÃ¡s gruesa
                            'thickness': 0.8,  # MÃ¡s larga que antes
                            'value': 48
                        }
                    }
                },
                # Mini aguja marcadora en 54%
                {
                    'type': 'indicator', 
                    'mode': 'gauge',
                    'value': 54,  # Valor fijo en 54%
                    'domain': {'x': [0, 1], 'y': [0, 1]},
                    'gauge': {
                        'axis': {'range': [45, 57], 'visible': False},  # Mismo rango, eje invisible
                        'bar': {'color': "transparent", 'thickness': 0},
                        'bgcolor': "transparent",
                        'borderwidth': 0,
                        'threshold': {
                            'line': {'color': "#ffc107", 'width': 4},  # Aguja amarilla mÃ¡s gruesa (mismo color)
                            'thickness': 0.8,  # MÃ¡s larga que antes
                            'value': 54
                        }
                    }
                }
            ],
            'layout': {
                'height': 240,
                'margin': {'l': 30, 'r': 30, 't': 50, 'b': 30},
                'paper_bgcolor': 'rgba(0,0,0,0)',
                'plot_bgcolor': 'rgba(0,0,0,0)',
                'font': {'color': '#374151', 'family': 'Inter, -apple-system, BlinkMacSystemFont, sans-serif', 'size': 12},
                'showlegend': False,
                'hovermode': False
            },
            'config': {'displayModeBar': False, 'responsive': True},
            'div_id': f"gauge-costo-{canal.lower().replace(' ', '-').replace('_', '-')}"
        }
        
        return gauge_config
        
    except Exception as e:
        print(f"Error creando configuraciÃ³n de gauge de costo: {e}")
        return None

def crear_gauge_ingreso_config(porcentaje_actual, canal="Canal"):
    """
    Crear configuraciÃ³n JSON de Plotly para gauge de ingreso real
    ConfiguraciÃ³n especÃ­fica para Metas de Ingreso Real con zona amarilla CENTRADA:
    - Rango visual: 5%-20% (15 puntos totales) para centrar zona objetivo
    - Rojo (5%-10%): Rentabilidad baja
    - Amarillo (10%-15%): Zona objetivo con degradado inteligente (12 segmentos)
    - Verde (15%-20%): Excelente rentabilidad
    - MISMO DISEÃ‘O VISUAL que metas de costo pero adaptado a rangos de ingreso real
    """
    try:
        # Validar entrada
        if porcentaje_actual is None or porcentaje_actual < 0:
            print(f"WARN: porcentaje_actual invÃ¡lido: {porcentaje_actual}, usando 12 por defecto")
            porcentaje_actual = 12.0
        gauge_config = {
            'data': [
                # Indicador principal
                {
                    'type': 'indicator',
                    'mode': 'gauge+number',
                    'value': porcentaje_actual,
                    'title': {'text': ""},  # Sin tÃ­tulo
                    'number': {
                        'font': {'size': 28, 'color': '#1a1a1a', 'family': 'Inter, -apple-system, sans-serif', 'weight': 700}, 
                        'suffix': "%",
                        'valueformat': '.1f'
                    },
                    'domain': {'x': [0, 1], 'y': [0, 1]},
                    'gauge': {
                        'axis': {
                            'range': [5, 20], 
                            'tickmode': 'array',
                            'tickvals': [5, 20],  # Solo extremos
                            'ticktext': ['5', '20'],  # Solo etiquetas extremas
                            'tickwidth': 2, 
                            'tickcolor': "#666", 
                            'ticklen': 10,
                            'tickfont': {'size': 9, 'color': '#4a5568', 'family': 'Inter, -apple-system, sans-serif'}
                        },
                        'bar': {'color': "transparent", 'thickness': 0},  # Sin lÃ­nea de progreso
                        'bgcolor': "rgba(248, 250, 252, 0.9)",
                        'borderwidth': 0,
                        'steps': [
                            # Rojo (5%-10%): Rentabilidad baja
                            {'range': [5, 7], 'color': "#dc3545"},    # Rojo puro
                            {'range': [7, 10], 'color': "#c82333"},   # Rojo intenso
                            
                            # DEGRADADO AMARILLO (10%-15%): De fuerte hacia verde
                            {'range': [10, 10.4], 'color': "#ff6f00"},  # Naranja-amarillo (cerca del rojo)
                            {'range': [10.4, 10.8], 'color': "#ff7043"},  # Casi naranja
                            {'range': [10.8, 11.2], 'color': "#ff8a65"},  # Amarillo-naranja fuerte
                            {'range': [11.2, 11.6], 'color': "#ff8f00"},  # Amarillo-naranja medio
                            {'range': [11.6, 12], 'color': "#ffa000"},    # Amarillo fuerte
                            {'range': [12, 12.4], 'color': "#ffb300"},    # Amarillo medio-fuerte
                            {'range': [12.4, 12.8], 'color': "#ffc107"},  # Amarillo estÃ¡ndar (centro)
                            {'range': [12.8, 13.2], 'color': "#ffd54f"},  # Amarillo medio-claro
                            {'range': [13.2, 13.6], 'color': "#ffe082"},  # Amarillo claro
                            {'range': [13.6, 14], 'color': "#ffecb3"},    # Amarillo suave
                            {'range': [14, 14.4], 'color': "#fff3cd"},    # Amarillo muy claro
                            {'range': [14.4, 15], 'color': "#fff8e1"},    # Amarillo muy claro (cerca del verde)
                            
                            # Verde (15%-20%): Excelente rentabilidad
                            {'range': [15, 17.5], 'color': "#28a745"},   # Verde Ã©xito puro
                            {'range': [17.5, 20], 'color': "#20c997"}     # Verde teal puro
                        ],
                        'threshold': {
                            'line': {'color': "#1f2937", 'width': 6},  # Aguja principal mÃ¡s gruesa y elegante
                            'thickness': 0.85,
                            'value': porcentaje_actual
                        },
                        'shape': "angular"
                    }
                },
                # Mini aguja marcadora en 10% 
                {
                    'type': 'indicator',
                    'mode': 'gauge',
                    'value': 10,  # Valor fijo en 10%
                    'domain': {'x': [0, 1], 'y': [0, 1]},
                    'gauge': {
                        'axis': {'range': [5, 20], 'visible': False},  # Mismo rango, eje invisible
                        'bar': {'color': "transparent", 'thickness': 0},
                        'bgcolor': "transparent",
                        'borderwidth': 0,
                        'threshold': {
                            'line': {'color': "#ffc107", 'width': 4},  # Aguja amarilla mÃ¡s gruesa
                            'thickness': 0.8,  # MÃ¡s larga que antes
                            'value': 10
                        }
                    }
                },
                # Mini aguja marcadora en 15%
                {
                    'type': 'indicator', 
                    'mode': 'gauge',
                    'value': 15,  # Valor fijo en 15%
                    'domain': {'x': [0, 1], 'y': [0, 1]},
                    'gauge': {
                        'axis': {'range': [5, 20], 'visible': False},  # Mismo rango, eje invisible
                        'bar': {'color': "transparent", 'thickness': 0},
                        'bgcolor': "transparent",
                        'borderwidth': 0,
                        'threshold': {
                            'line': {'color': "#ffc107", 'width': 4},  # Aguja amarilla mÃ¡s gruesa (mismo color)
                            'thickness': 0.8,  # MÃ¡s larga que antes
                            'value': 15
                        }
                    }
                }
            ],
            'layout': {
                'height': 240,
                'margin': {'l': 30, 'r': 30, 't': 50, 'b': 30},
                'paper_bgcolor': 'rgba(0,0,0,0)',
                'plot_bgcolor': 'rgba(0,0,0,0)',
                'font': {'color': '#374151', 'family': 'Inter, -apple-system, BlinkMacSystemFont, sans-serif', 'size': 12},
                'showlegend': False,
                'hovermode': False
            },
            'config': {'displayModeBar': False, 'responsive': True},
            'div_id': f"gauge-ingreso-{canal.lower().replace(' ', '-').replace('_', '-')}"
        }
        
        return gauge_config
        
    except Exception as e:
        print(f"Error creando configuraciÃ³n de gauge de ingreso real: {e}")
        return None

def calcular_top_skus(df_filtrado, limite=None, channels=None, warehouses=None, skus=None):
    """Calcula el ranking completo de SKUs con ventas ordenados por unidades (descendente) - CON FILTROS APLICADOS"""
    if df_filtrado.empty:
        print("DEBUG: DataFrame estÃ¡ vacÃ­o")
        return []
    
    print(f"DEBUG: DataFrame original tiene {len(df_filtrado)} filas")
    print(f"DEBUG: Estados Ãºnicos: {df_filtrado['estado'].unique()}")
    print(f"DEBUG: Primeras 3 filas de cantidad: {df_filtrado['cantidad'].head(3).tolist()}")
    
    # Filtrar solo Ã³rdenes de venta (excluir cancelados)
    df_activo = df_filtrado[df_filtrado["estado"] == "Orden de Venta"]
    
    if df_activo.empty:
        print("DEBUG: No hay Ã³rdenes de venta despuÃ©s del filtro")
        return []
    
    print(f"DEBUG: DespuÃ©s del filtro de estado: {len(df_activo)} filas")
    
    # APLICAR FILTROS ADICIONALES
    if channels:
        df_activo = df_activo[df_activo["Channel"].isin(channels)]
        print(f"DEBUG: DespuÃ©s del filtro de canales: {len(df_activo)} filas")
    
    if warehouses:
        df_activo = df_activo[df_activo["Warehouse"].isin(warehouses)]
        print(f"DEBUG: DespuÃ©s del filtro de bodegas: {len(df_activo)} filas")
        
    if skus:
        df_activo = df_activo[df_activo["sku"].isin(skus)]
        print(f"DEBUG: DespuÃ©s del filtro de SKUs: {len(df_activo)} filas")
    
    if df_activo.empty:
        print("DEBUG: No quedan datos despuÃ©s de aplicar filtros")
        return []
    
    # Verificar tipos de datos
    print(f"DEBUG: Tipo de dato en columna cantidad: {df_activo['cantidad'].dtype}")
    print(f"DEBUG: Ejemplo de valores cantidad: {df_activo['cantidad'].head(10).tolist()}")
    
    # Convertir cantidad a numÃ©rico si es necesario
    df_activo = df_activo.copy()
    df_activo['cantidad'] = pd.to_numeric(df_activo['cantidad'], errors='coerce')
    df_activo = df_activo.dropna(subset=['cantidad'])
    
    print(f"DEBUG: DespuÃ©s de limpiar cantidad: {len(df_activo)} filas")
    
    # Agrupar por SKU y descripciÃ³n, sumar cantidades y totales
    top_skus = df_activo.groupby(['sku', 'descripcion']).agg({
        'cantidad': 'sum',      # Total unidades vendidas (suma de todas las cantidades)
        'Total': 'sum'          # Total monto vendido (suma de todos los montos)
    }).reset_index()
    
    print(f"DEBUG: DespuÃ©s de agrupar: {len(top_skus)} SKUs Ãºnicos")
    print(f"DEBUG: Top 3 cantidades: {top_skus.nlargest(3, 'cantidad')[['sku', 'cantidad']].to_dict('records')}")
    
    # Ordenar por cantidad (nÃºmero de unidades) descendente
    top_skus = top_skus.sort_values('cantidad', ascending=False)
    if limite:
        top_skus = top_skus.head(limite)
    
    # Convertir a lista de diccionarios para el template
    resultado = []
    for _, row in top_skus.iterrows():
        unidades = int(row['cantidad'])
        monto = float(row['Total'])
        precio_promedio = monto / unidades if unidades > 0 else 0
        
        resultado.append({
            'sku': row['sku'],
            'descripcion': row['descripcion'],
            'unidades': unidades,           # Total de unidades vendidas
            'monto': monto,                 # Total monto vendido
            'precio_promedio': precio_promedio  # Precio promedio por unidad
        })
    
    print(f"DEBUG: Resultado final: {len(resultado)} SKUs")
    if resultado:
        print(f"DEBUG: Primer SKU: {resultado[0]}")
    
    return resultado

# FunciÃ³n para obtener SKUs especÃ­ficos
def get_specific_skus_with_descriptions(df):
    """Obtiene los SKUs especÃ­ficos con sus descripciones"""
    # SKUs que queremos mostrar en el filtro
    target_skus = ['2000005', '9900157', '2000013', '9900021', '9900027', '2000040', '2000020', '2000002','2000026','2000032','9900023']
    
    try:
        # Filtrar el dataframe para obtener solo estos SKUs
        df_skus = df[df['sku'].isin(target_skus)].copy()
        
        if df_skus.empty:
            print("DEBUG: No se encontraron los SKUs especificados en los datos")
            return []
        
        # Obtener SKU y descripciÃ³n Ãºnicos
        skus_with_desc = df_skus.groupby('sku')['descripcion'].first().reset_index()
        
        # Crear lista de diccionarios con SKU y descripciÃ³n
        skus_disponibles = []
        for _, row in skus_with_desc.iterrows():
            skus_disponibles.append({
                'sku': row['sku'],
                'descripcion': row['descripcion'][:60] + '...' if len(row['descripcion']) > 60 else row['descripcion']
            })
        
        # Ordenar por SKU
        skus_disponibles.sort(key=lambda x: x['sku'])
        
        print(f"=== SKUs ESPECÃFICOS ENCONTRADOS ===")
        for sku_info in skus_disponibles:
            print(f"SKU: {sku_info['sku']} - {sku_info['descripcion']}")
        
        return skus_disponibles
        
    except Exception as e:
        print(f"Error obteniendo SKUs especÃ­ficos: {e}")
        return []

# FUNCIONES PARA METAS Y CUMPLIMIENTO
def load_metas_diarias():
    """Carga las metas diarias desde ClickHouse Silver.metas_diarias_canal"""
    client = get_db_connection()
    if not client:
        print("ERROR: No se pudo conectar a ClickHouse")
        return create_mock_metas()
    
    try:
        # Primero verificar si la tabla existe
        check_query = "EXISTS TABLE Silver.metas_diarias_canal"
        exists_result = client.query(check_query)
        table_exists = exists_result.result_rows[0][0] if exists_result.result_rows else False
        
        if not table_exists:
            print("ADVERTENCIA: Tabla Silver.metas_diarias_canal no existe. Usando datos mock.")
            return create_mock_metas()
        
        # Verificar estructura de la tabla
        describe_query = "DESCRIBE Silver.metas_diarias_canal"
        describe_result = client.query(describe_query)
        columns_info = describe_result.result_rows
        column_names = [row[0] for row in columns_info]
        
        print(f"Columnas disponibles en Silver.metas_diarias_canal: {column_names}")
        
        # Verificar si existe la columna Canal o M.Canal
        canal_column = None
        if 'Canal' in column_names:
            canal_column = 'Canal'
        elif 'M.Canal' in column_names:
            canal_column = 'M.Canal'
        
        if not canal_column:
            print("ERROR: Columna de canal no encontrada en la tabla. Estructura actual:")
            for col_info in columns_info:
                print(f"  - {col_info[0]}: {col_info[1]}")
            print("Usando datos mock...")
            return create_mock_metas()
        
        print(f"INFO: Usando columna de canal: {canal_column}")
        
        # Usar alias para normalizar el nombre de la columna
        query = f"""
        SELECT
            `{canal_column}` AS Canal,
            Fecha,
            Meta_Diaria,
            Meta_Acumulada,
            Meta_Mensual,
            Meta_Ingreso_Real_Diaria,
            Meta_Ingreso_Real_Acumulada,
            Meta_Ingreso_Real_Mensual,
            Modelo_Usado,
            dias_del_mes,
            Porcentaje_Semanal,
            Dias_DOW_en_Mes
        FROM Silver.metas_diarias_canal
        ORDER BY `{canal_column}`, Fecha
        """
        print(f"INFO: Ejecutando query: {query}")
        result = client.query(query)
        df_metas = pd.DataFrame(result.result_rows, columns=result.column_names)
        
        print(f"INFO: Query ejecutado exitosamente. Filas obtenidas: {len(df_metas)}")
        if not df_metas.empty:
            print(f"INFO: Primeras fechas: {df_metas['Fecha'].head(3).tolist()}")
            print(f"INFO: Canales encontrados: {df_metas['Canal'].unique().tolist()}")
            print(f"INFO: Suma total Meta_Diaria: ${df_metas['Meta_Diaria'].sum():,.0f}")
        
        if df_metas.empty:
            print("ERROR: Tabla Silver.metas_diarias_canal estÃ¡ vacÃ­a pero existe.")
            print("INFO: Verificando contenido de la tabla...")
            count_result = client.query("SELECT COUNT(*) FROM Silver.metas_diarias_canal")
            row_count = count_result.result_rows[0][0]
            print(f"INFO: La tabla tiene {row_count} registros en ClickHouse")
            print("USANDO DATOS MOCK como Ãºltimo recurso...")
            return create_mock_metas()
        
        # Convertir tipos
        df_metas["Fecha"] = pd.to_datetime(df_metas["Fecha"])
        df_metas["Meta_Diaria"] = pd.to_numeric(df_metas["Meta_Diaria"], errors='coerce')
        df_metas["Meta_Acumulada"] = pd.to_numeric(df_metas["Meta_Acumulada"], errors='coerce')
        df_metas["Meta_Mensual"] = pd.to_numeric(df_metas["Meta_Mensual"], errors='coerce')
        
        # Verificar que no hay valores NaN despuÃ©s de la conversiÃ³n
        nan_count = df_metas["Meta_Diaria"].isna().sum()
        if nan_count > 0:
            print(f"WARNING: {nan_count} valores NaN encontrados en Meta_Diaria despuÃ©s de conversiÃ³n")
            df_metas = df_metas.dropna(subset=['Meta_Diaria'])
            print(f"INFO: Registros despuÃ©s de limpiar NaN: {len(df_metas)}")
        
        print(f"=== METAS CARGADAS DESDE CLICKHOUSE EXITOSAMENTE ===")
        print(f"Registros de metas: {len(df_metas)}")
        print(f"Canales con metas: {df_metas['Canal'].nunique()}")
        print(f"Canales: {df_metas['Canal'].unique().tolist()}")
        print(f"Rango de fechas metas: {df_metas['Fecha'].min()} a {df_metas['Fecha'].max()}")
        print(f"Suma total Meta_Diaria (despuÃ©s de conversiÃ³n): ${df_metas['Meta_Diaria'].sum():,.0f}")
        
        return df_metas
        
    except Exception as e:
        print(f"ERROR CRÃTICO cargando metas desde ClickHouse: {e}")
        print(f"Tipo de error: {type(e).__name__}")
        print("FALLBACK: Usando datos mock como Ãºltimo recurso...")
        print("RECOMENDACIÃ“N: Revisar conexiÃ³n a ClickHouse y estructura de datos")
        return create_mock_metas()

def create_mock_metas():
    """Crea datos mock de metas para testing"""
    from datetime import date
    import calendar
    
    print("=== CREANDO DATOS MOCK DE METAS ===")
    
    # Obtener el mes actual y anterior
    hoy = date.today()
    primer_dia_mes_actual = hoy.replace(day=1)
    
    # Mes anterior
    if hoy.month == 1:
        primer_dia_mes_anterior = hoy.replace(year=hoy.year-1, month=12, day=1)
    else:
        primer_dia_mes_anterior = hoy.replace(month=hoy.month-1, day=1)
    
    ultimo_dia_mes_anterior = primer_dia_mes_actual - timedelta(days=1)
    
    # Metas mensuales por canal (basadas en los datos reales del sistema)
    metas_mensuales = {
        'Mercado Libre': 20500000.0,
        'CrediTienda': 6000000.0,
        'Walmart': 4300000.0,
        'Liverpool': 3000000.0,
        'Shein': 2400000.0,
        'Yuhu': 1300000.0,
        'Aliexpress': 100000.0,
        'Betterware': 500000.0,
        'Coppel': 800000.0,
        'Doto': 300000.0
    }
    
    mock_data = []
    
    # Generar datos para mes anterior y mes actual
    for fecha_inicio, fecha_fin in [(primer_dia_mes_anterior, ultimo_dia_mes_anterior), 
                                   (primer_dia_mes_actual, hoy)]:
        
        dias_mes = (fecha_fin - fecha_inicio).days + 1
        fecha_actual = fecha_inicio
        
        while fecha_actual <= fecha_fin:
            for canal, meta_mensual in metas_mensuales.items():
                # Meta diaria uniforme (simplificada)
                meta_diaria = meta_mensual / calendar.monthrange(fecha_actual.year, fecha_actual.month)[1]
                
                # Meta acumulada hasta la fecha
                dia_del_mes = fecha_actual.day
                meta_acumulada = meta_diaria * dia_del_mes
                
                mock_data.append({
                    'Canal': canal,
                    'Fecha': fecha_actual,
                    'dow': fecha_actual.weekday() + 1,
                    'nombre_dia': fecha_actual.strftime('%A'),
                    'Meta_Mensual': meta_mensual,
                    'dias_del_mes': calendar.monthrange(fecha_actual.year, fecha_actual.month)[1],
                    'Modelo_Usado': 'UNIFORME',
                    'Meta_Diaria': round(meta_diaria, 2),
                    'Meta_Acumulada': round(meta_acumulada, 2),
                    'Porcentaje_Semanal': 14.29,  # 100/7 dÃ­as
                    'Dias_DOW_en_Mes': 4
                })
            
            fecha_actual += timedelta(days=1)
    
    df_mock = pd.DataFrame(mock_data)
    
    print(f"Datos mock creados: {len(df_mock)} registros")
    print(f"Canales: {df_mock['Canal'].nunique()}")
    print(f"Rango de fechas: {df_mock['Fecha'].min()} a {df_mock['Fecha'].max()}")
    
    return df_mock

